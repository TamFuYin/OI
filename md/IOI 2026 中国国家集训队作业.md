怎么这么困难

## 1. Cells Blocking

考虑「最左路径」（尽量向下走）和「最右路径」（尽量向右走），则所有可能的路径都被这两条路径「包裹」

容易发现割点就是这两条路径的交集。

现在这道题允许我们割掉两个点，考虑先固定一个点，然后快速计算割掉一个点之后的割点数量。

如果这个点已经是割点，则剩下所有点都是合法的；

否则，如果他在两条路径中间，可以发现他对答案不产生影响，答案为原来的割点数量。

否则，如果他在两条路径之一，则可能会把它所在的这条路径废掉，改道可能产生更多的割点。

由于路径长度是 $O(n)$ 的，每次暴力把新的路径搜出来并更新也可以做到 $O(n)$，总复杂度 $O(n^2)$，所以这样就做完了。

## 2. Giant Penguin

考虑点分树，则由于点分中心最多覆盖 $k$ 条非树边，我们可以把非树边挂到点分 LCA 上，每个点最多挂 $k$ 条边。

然后对于修改操作，跳点分树，对于每个点分中心，我们提取出所有的关键点，跑一遍 dijkstra 更新答案。

对于每个点，我们维护 $d+c$ 表示答案，其中 $d$ 表示到点分中心的距离，然后打一个 $c$ 的 ckmin 标记即可。

询问时，做一遍树链剖分把 ckmin 标记合并起来。

时间复杂度两只 log。

## 3. Edit Distance Yet Again

考虑编辑距离最经典的 DP：
$$
f_{i,j}=\min(f_{i-1,j-1}+[s_i=t_j],f_{i-1,j}+1,f_{i,j-1}+1)
$$

时间复杂度是 $O(n^2)$

首先不难发现 $|i-j|\le k$，这样即把状态压缩至 $O(nk)$。

然后我们互换定义域和值域，现在我们设 $g_{x,y}$ 表示使 $f_{i,j}=x,i-j=y$ 的最大的 $i$，可以按照 $x$ 的顺序从小到大转移。

每次转移需要匹配一段相同的位置，因为这一段对 $x$ 的贡献为 $0$，用一个 SA 求一下 LCP 即可。


## 4. Cactus

> Those less acquainted with botany may now appreciate a refresher😂

前置知识：色多项式。

无向图 $G$ 的色多项式 $P(G,t)$ 描述 $G$ 的 $t$-着色数量，是一个关于 $t$ 的多项式。

对于树的情况，$P(T_n,t)=t(t-1)^{n-1}$，因为只要保证每个点不与其父亲的颜色相同即可。

对于环的情况，$P(C_n,t)=(t-1)^n+(-1)^n(t-1)$。

色多项式有一个简单的递推公式。$P(G,t)=P(G-e,t)-P(G/e,t)$，其中 $G-e$ 表示删除边 $e$，$G/e$ 表示缩边 $e$。

可以用来验证环的色多项式：$P(C_n,t)=P(T_n,t)-P(C_{n-1},t)$。

还有一个关键公式，如果 $G$ 可以分解为 $G_1,G_2$，且两者只共享一个顶点，则
$$
P(G,t)=P(G_1,t)\cdot P(G_2,t)/t
$$

借助这个公式，我们可以把仙人掌拆成若干棵树与环的拼接，每个的色多项式都能直接算出来。

记 $Bridge$ 表示不在环中的边的数量，每个环的长度为 $len_i$，则答案为

$$
t\cdot(t-1)^{Bridge}\prod_{i\in C}\frac{(t-1)^{len_i}+(-1)^{len_i}(t-1)}{t}
$$

讲个笑话：我一个 tarjan 调了半个下午

## 5. Social Distancing

考虑归中的思想，把两个状态化为一个标准状态。

考虑把所有结点按深度从深到浅排序，如果这个点是可以被选的（即它的儿子都没有被选）则找一个子集中的点把它推过来。

在多数情况下都是可以拉过来的，但是如果 $v$ 的兄弟已经被选了，则 $u$ 无法进入他的父亲，此时就不能拉过来。

还有一种情况，就是如果 $u$ 到 $v$ 的路径上某个点的兄弟上有一个点，则它也过不了。

我们需要把这个点尽量往远推。

对于每个子集中的点，如果他不是 $v$ 的祖先，则尽量把它往子节点移动。

我们可以发现这样就可以规避所有的冲突情况。

## 6. Social Justice

先按照 $a_i$ 排序。

显然最优的方案是选择一段区间。

考虑找到所有的最小的合法区间，然后区间内的元素将被保留。

但是这样会
```
wrong answer 470th numbers differ - expected: '9', found: '10'
```

因为最优解是区间不一定全部的合法解都是区间，可能有一些解包含包含某个元素，但是在所有的合法区间解中找不到这个元素。

因此我们只需要考虑形如 $i\cup R$ 的解，其中 $R$ 是一段区间。

由于最优解的长度已经确定，所以实际上只有 $O(n)$ 个合法的 $R$。

考虑如果 $i$ 在 $R$ 左边，则我们希望找到 $a_r\le K\cdot\dfrac{s_r-s_{l-1}+a_i}{r-l+2}$ 成立的 $R$，不难发现我们只需要求出 $a_r\cdot(r-l+2)/K-s_r+s-{l-1}$ 的最小值即可。

考虑如果 $i$ 在 $R$ 右边，则我们希望找到 $a_i\le K\cdot\dfrac{s_r-s_{l-1}+a_i}{r-l+2}$ 成立的 $R$，不难发现我们只需要求出 $\dfrac{s_r-s_{l-1}}{(r-l+2)/K-1}$ 的最大值即可。

那么如何求出最小的合法区间？固定 $r$，则我们需要找到使 $a_r\le K\cdot \dfrac{s_r-s_{l-1}}{r-l+1}$ 满足的最大的 $l$，可以用斜率优化之类的求出来。

## 7. Final Exam

做过了，但是当时没看懂。

问题相当于给出 $n$ 个分段二次函数，求出他们的 max-plus 卷积。

根据闵可夫斯基和的经典做法，我们可以考虑按照斜率排序，优先选择较大的斜率。

这里的二次函数我们可以看成无数段线性函数的拼接，我们仍然可以通过二分斜率的方式求出 max-plus 卷积的形状。

对于 $a_i>0$，我们要么选择 $x=0$，要么选择右半边的函数，所以要 $2^k$ 枚举。

## 8. Travel around China

同一场比赛，当时顺路看了这道题，也是聪明的。

我们先来考虑 $n=2$ 的情况，考虑分治。

考虑目前分治中心 $mid$，我们处理出以 $mid-1$ 结尾的所有最短路径和以 $mid+1$ 开始的所有最短路径，然后每次合并一下。

$n=3$ 类似。

## 9. Thanks to MikeMirzayanov

我貌似还真做过「原题」

考虑相邻合法对，因为这样的对一旦出现就不会拆开，可以看作缩点。

我们发现一次操作会使一个区间的 $r$ 与上一个区间的 $l$ 相连。

因此我们每次找到所有的相邻逆序对，然后尽可能地使他们合并。

## 10. Excluded Min

这个操作相当于可以把它均摊倒开，我们相当于找到最大的 $x$ 满足区间内 $< x$ 的数量至少有 $x$ 个。

但是问题来了，这个问题不一定满足单调性，因为比较小的 $x$ 也可能不合法。

考虑维护前缀和减去 $x$，然后我们相当于查询 $\ge 0$ 的最大位置。

然后不难主席树维护。

## 11. Best Subsequence

注意到序列中的最小值一定会被选，所以我们可以固定它做起点。

二分答案，根据一个经典的套路，我们可以把序列中的元素分为 $\le W/2$ 和 $>W/2$ 两部分。

我们知道

- 两个 $\le W/2$ 的元素一定能匹配
- 两个 $>W/2$ 的元素一定不能匹配

我们基础的答案即为 $\le W/2$ 的元素的个数，然后每两个 $\le W/2$ 的元素之间可以夹最多一个 $>W/2$ 的元素，且要求这个元素与两边都能匹配。

但是有多组询问怎么搞？

考虑整体二分。

如果我们知道整个序列的这个答案的形态，然后对于一段区间的答案，我们找到左侧第一个 $\le W/2$ 的元素 $i$，和右侧第一个 $\le W/2$ 的元素 $j$，然后在 $[l,i)\cup (j,r]$ 之间找一个 $\le W-\max(a_i,a_j)$ 的元素即可，这里可以用一个 ST 表找最小值。

## 12. Binary Search Tree

哦哦确实做过，很聪明。

首先这个区间插入很难搞，我们考虑把所有的操作和询问离线下来扫描线，对于区间插入 $[l,r]$，我们只需要在 $l$ 时插入这个结点然后在 $r+1$ 时删除即可。

为了不丢失时间的信息，我们需要在插入结点时记录一下时间 $t$，查询时只考虑时间 $<t$ 的结点。

不难发现我们的 BST 在考虑 $(w,t)$ 时实际上形如一个笛卡尔树，其中 $w$ 为 key，$t$ 为 priority。

因此在只考虑祖先信息的情况下，只保留 $<t$ 的结点和什么都不做其实都是一样的。

然后问题就变成动态维护笛卡尔树，查询祖先树链信息。

这个东西有点复杂，但是我们发现祖先树链信息只要查看左侧的后缀最小值和右侧的前缀最小值即可。

然后你发现这个东西就是兔队线段树的板子，这样就做完了。

## 13. Game

也做过。

考虑记从 $i$ 开始的最优期望得分为 $f_i$。

则我们知道 $f_1=A_1,f_n=A_n$，对于 $1<i<n,f_i=\max\{A_i,(f_{i-1}+f_{i+1})/2\}$。

有点抽象，我们不妨把 $\max$ 重写为不等式，然后尝试找到下确界。

则 $f_i\ge A_i,2f_i\ge f_{i-1}+f_{i+1}$。

注意到右边的不等式实际上意味着 $f$ 是一个凹函数，这是显然的，因为在中间的时候得分肯定比较多。

所以我们求出 $\{(i,A_i)\}$ 的凸包即可。

## 14. Local Maxima

为什么题目要求你只有恰好一个全局最大值？因为至少有一个全局最大值，那就是 $nm$。

考虑从大到小加入元素，那么除了第一个元素 $nm$ 以外，我们要求每个元素加入时，它的行或者列都至少已经有一个元素已加入。

这个怎么刻画 DP 状态？

注意到一个状态转移到下一个状态的形态只与他的不同的行和列的数量有关。

记 $f_{i,x,y}$ 表示目前加入了后 $i$ 个元素，且这些元素占据 $x$ 行 $y$ 列，则
- $f_{i+1,x+1,y}\gets y(n-x)\cdot f_{i,x,y}$
- $f_{i+1,x,y+1}\gets x(m-y)\cdot f_{i,x,y}$
- $f_{i+1,x,y}\gets (xy-i)\cdot f_{i,x,y}$

注意到这个东西形如一个带标号计数体系。

- $g_{x+1,y}\gets (n-x)\frac{y}{x+1}\frac{((x+1)y-1)!}{(xy-1)!}g_{x,y}$
- $g_{x,y+1}\gets (m-y)\frac{x}{y+1}\frac{((y+1)x-1)!}{(xy-1)!}g_{x,y}$

## 15. 100 Boxes Per Hour...

貌似在哪里做过类似题目。

考虑分类讨论，不妨让 $A>B>C$，如果 $B+C\ge 43$，则怎么放都行，只要不舍弃即可。

否则，我们知道 $A\ge 58$，$C\le 21$

我们还有一种简单的策略：对于每种颜色，把前 $C$ 次出现都丢弃掉，这种情况合法如果 $100-3C\ge 43$，即 $C\le 19$。

对于剩下的情况，考虑一种贪心的想法，对于每个颜色，能放就放，否则找到数量最少的一堆，如果这一堆 $<43/2$ 就清空这一堆，否则舍弃。

## 16. Designing a PCB

相当于把所有的颜色分为两组，使得每一组内部都不存在交叉。

考虑在两个交叉颜色之间连边，然后判断是否是二分图即可。

## 17. Knowledge Is...

讲个笑话：一开始没看到「Also, students are not very interested in hard work, so each student will work on a maximum of two projects.」然后想了半天。

相当于给区间做匹配，匹配的数量越多越好。

考虑反悔贪心。

发现如果某个可以跟他匹配的元素在跟一个 $r$ 比他小的元素匹配的话，把那个元素踢掉换成他不会更劣。

所以我们按照 $r$ 排序，这样就做完了。

## 18. Lights On The Road

考虑题目实际上可以转化为一个 DAG 最短路问题，有边

- $i\to i+1$，费用为 $a_{i+1}$
- $i\to i+2$，费用为 $a_{i+2}$
- $i\to i+3$，费用为 $a_{i+3}$

考虑从后往前递推，在最短路 DAG 上用左偏树或者线段树合并维护所有可能的路径差分，然后用优先队列在堆上选出前 $K$ 个即可。

## 19. Koosaga's Problem

考虑奇环，但是我们怎么找到图的全部奇环呢？

考虑建出一棵生成树，用环基生成所有环。

考虑异或哈希，对于每条环上的边都打上同一个异或，不同的树边打不同的标记。

则图是一个二分图，当且仅当总的异或和为 $0$。

判断 $|S|=1$，只需要看一下总的异或和是否与某条边的异或和相同。

判断 $|S|=2$，只需要看一下是否存在两条边异或起来与总的异或和相同，枚举一条边即可。

## 20. Rhythm Game

$C_j\ge C_{j+1}$ 很不符合常识啊……这不是在鼓励不连击吗。

虽然不符合常识，但是符合四边形不等式。

记 $f_{i,j}$ 表示前 $i$ 个音符总共 hit 到 $j$ 个，且 $i$ 恰为一次 combo 的末尾，的最高得分。

然后你发现他是一个离线决策单调性，可以用 LARSCH 解决。

## 21. Stone Catch Game

我们考虑如果 Platina 只有一块石子。

那么 Platina 能够获胜当且仅当 Yuto 一直往上走或者一直往右走的情况下都不能逃脱。

对于多颗石子，其实只需要保留最多两颗，一颗用来抓向上走，一颗用来抓向右走。

## 22. Setting Maps

如果 $K=1$，则拆点之后，问题为最小割。

考虑分层图，每一层的入点向下一层的出点连一条流量无穷大的边。

## 23. How to Move the Beans

首先不同的豆子显然是独立的，所以我们算出来 SG 的异或即可。

由于题目已经强行给我们设定了一个 DP 状态了，我们不妨从下到上，设 $f_{i,j}$ 表示从 $(i,j)$ 出发的 SG。

然后在每一行内，你一旦选择一个方向就不能走回头路，选择一个位置进入下一行。

记 $g_{i,j}$ 表示从右边过来且目前走到 $(i,j)$ 的 SG，$h$ 是从左边过来，则

$$
g_{i,j}=\operatorname{mex}\{f_{i+1,j},g_{i,j-1}\}\\
h_{i,j}=\operatorname{mex}\{f_{i+1,j},h_{i,j+1}\}\\
f_{i,j}=\operatorname{mex}\{g_{i,j-1},h_{i,j+1},f_{i+1,j}\}
$$

但是这样可能会出错。因为我们可能走到原来的位置。

如果当前行存在 `#`，则他是可以顺序转移的，我们可以快速计算出来答案。

否则，我们得设 $g_{i,j,k}$ 表示走了 $k$ 步的结果，$h$ 同理，然后

$$
g_{i,j,k}=\operatorname{mex}\{f_{i+1,j},g_{i,j-1,k+1}\}\\
h_{i,j,k}=\operatorname{mex}\{f_{i+1,j},h_{i,j+1,k+1}\}\\
f_{i,j}=\operatorname{mex}\{g_{i,j-1,0},h_{i,j+1,0},f_{i+1,j}\}
$$

这个东西怎么算呢？你发现你相当于每次从一个位置开始按顺序 $\operatorname{mex}$ 上 $f$，所以实际上我们可以用**倍增**或者简单地线段树计算出 $g_{i,j-1,0}$ 和 $h$。然后就做完了。

## 24. Interesting Coloring

考虑建生成树，我们令这条特殊的 bypass path 即为环基。

如何给树染色？考虑维护走到 $u$ 时根到 $u$ 的路径使用的颜色集合 $C$。

考虑一个拓展的树链剖分，对于 $u$ 的所有儿子，按照子树大小排序，对于前 $|C|$ 个使用 $C$ 中颜色，否则使用新颜色。

对于返祖边，我们可以给他随便赋一个在两个端点处都没有出现的颜色。

可以证明这样使用的颜色数量不超过 $8$。（其实我不会证

……是真的，我发现碰到无向图上环的问题，不是生成树环基就是圆方树，没有别的算法了（最多算上耳分解之类的双极定向）

## 25. Joy with Permutations

怎么又是做过的题（？

考虑如果 $n=4$，只使用操作 $1$ 得到的信息。不难发现我们永远也不可能知道他是顺序的还是逆序的，只能知道一个方向不确定的排列。

考虑询问 $i,j,k$，不妨假设得到的中位数为 $j$。

考虑再询问 $j,k,l$，

- 如果得到的中位数为 $j$，则我们知道 $i,l$ 一定在 $j$ 的同一侧，此时再询问一次 $i,j,l$ 即可知道哪个元素更靠近 $j$，得到 $k,j,i,l$ 或者 $k,j,l,i$
- 否则，如果得到的中位数为 $k$，则直接得到 $i,j,k,l$ 的顺序。
- 否则，如果得到的中位数为 $l$，则直接得到 $i,j,l,k$。

考虑拓展这个过程，发现形如每次把一个元素插入到原先的空隙中，直接二分查找即可做到 $O(N\log N)$ 次查询。

这个时候我发现自己看错题了，回答的是中位数的**值**而非编号。

如果是编号的话，从信息论的角度就是不可能的（因为基于比较的排序的时间复杂度是 $\Theta(N\log N)$。

我们问出来 $a_1,a_2,a_3,a_4$ 的顺序，不妨假设 $a_i<a_j<a_k<a_l$，我们问若干次知道 $a_j,a_k$ 的值，设为 $L$ 和 $H$。

我们维护最小的两个数和最大的两个数，并维护次小值和次大值。

每次加入 $a_x$ 时询问 $a_i,a_l,a_x$：

- 如果 $x<L$，那么可能是 $a_x$，也可能是把 $a_i$ 给问出来了。但是我们不用管它，我们只需要知道一套这个东西就行了，所以有了 $(i,x,k,l)$，$L\gets$ 新的返回值
- 其余也类似。


## 26. Lazy Judge

交互，懒得做了

## 27. AND Permutation

即 $A$ 是一个关于子集关系的闭包。

考虑按照最低位为 $0/1$ 分类，则要求 $1$ 之间不能匹配。

我们知道对于每个 $1$ 他都有一个对应的 $0$。

首先我们递归求出 $0$ 和 $1$ 去除这一位之后内部的匹配情况。

对于每个 $1$，我们知道他去除这一位之后的匹配情况再加上 $0$ 之后一定在 $0$ 中，所以就跟他匹配。

对于每个 $0$，如果他的匹配对象加上 $1$ 之后在 $1$ 中，就跟这个 $1$ 匹配；否则跟加上 $0$ 后的匹配对象匹配。

这样就能做到不重不漏地匹配

## 28. Permutation CFG

