怎么这么困难

## 1. Cells Blocking

考虑「最左路径」（尽量向下走）和「最右路径」（尽量向右走），则所有可能的路径都被这两条路径「包裹」

容易发现割点就是这两条路径的交集。

现在这道题允许我们割掉两个点，考虑先固定一个点，然后快速计算割掉一个点之后的割点数量。

如果这个点已经是割点，则剩下所有点都是合法的；

否则，如果他在两条路径中间，可以发现他对答案不产生影响，答案为原来的割点数量。

否则，如果他在两条路径之一，则可能会把它所在的这条路径废掉，改道可能产生更多的割点。

由于路径长度是 $O(n)$ 的，每次暴力把新的路径搜出来并更新也可以做到 $O(n)$，总复杂度 $O(n^2)$，所以这样就做完了。

## 2. Giant Penguin

考虑点分树，则由于点分中心最多覆盖 $k$ 条非树边，我们可以把非树边挂到点分 LCA 上，每个点最多挂 $k$ 条边。

然后对于修改操作，跳点分树，对于每个点分中心，我们提取出所有的关键点，跑一遍 dijkstra 更新答案。

对于每个点，我们维护 $d+c$ 表示答案，其中 $d$ 表示到点分中心的距离，然后打一个 $c$ 的 ckmin 标记即可。

询问时，做一遍树链剖分把 ckmin 标记合并起来。

时间复杂度两只 log。

## 3. Edit Distance Yet Again

考虑编辑距离最经典的 DP：
$$
f_{i,j}=\min(f_{i-1,j-1}+[s_i=t_j],f_{i-1,j}+1,f_{i,j-1}+1)
$$

时间复杂度是 $O(n^2)$

首先不难发现 $|i-j|\le k$，这样即把状态压缩至 $O(nk)$。

然后我们互换定义域和值域，现在我们设 $g_{x,y}$ 表示使 $f_{i,j}=x,i-j=y$ 的最大的 $i$，可以按照 $x$ 的顺序从小到大转移。

每次转移需要匹配一段相同的位置，因为这一段对 $x$ 的贡献为 $0$，用一个 SA 求一下 LCP 即可。


## 4. Cactus

> Those less acquainted with botany may now appreciate a refresher😂

前置知识：色多项式。

无向图 $G$ 的色多项式 $P(G,t)$ 描述 $G$ 的 $t$-着色数量，是一个关于 $t$ 的多项式。

对于树的情况，$P(T_n,t)=t(t-1)^{n-1}$，因为只要保证每个点不与其父亲的颜色相同即可。

对于环的情况，$P(C_n,t)=(t-1)^n+(-1)^n(t-1)$。

色多项式有一个简单的递推公式。$P(G,t)=P(G-e,t)-P(G/e,t)$，其中 $G-e$ 表示删除边 $e$，$G/e$ 表示缩边 $e$。

可以用来验证环的色多项式：$P(C_n,t)=P(T_n,t)-P(C_{n-1},t)$。

还有一个关键公式，如果 $G$ 可以分解为 $G_1,G_2$，且两者只共享一个顶点，则
$$
P(G,t)=P(G_1,t)\cdot P(G_2,t)/t
$$

借助这个公式，我们可以把仙人掌拆成若干棵树与环的拼接，每个的色多项式都能直接算出来。

记 $Bridge$ 表示不在环中的边的数量，每个环的长度为 $len_i$，则答案为

$$
t\cdot(t-1)^{Bridge}\prod_{i\in C}\frac{(t-1)^{len_i}+(-1)^{len_i}(t-1)}{t}
$$

讲个笑话：我一个 tarjan 调了半个下午

## 5. Social Distancing

考虑归中的思想，把两个状态化为一个标准状态。

考虑把所有结点按深度从深到浅排序，如果这个点是可以被选的（即它的儿子都没有被选）则找一个子集中的点把它推过来。

在多数情况下都是可以拉过来的，但是如果 $v$ 的兄弟已经被选了，则 $u$ 无法进入他的父亲，此时就不能拉过来。

还有一种情况，就是如果 $u$ 到 $v$ 的路径上某个点的兄弟上有一个点，则它也过不了。

我们需要把这个点尽量往远推。

对于每个子集中的点，如果他不是 $v$ 的祖先，则尽量把它往子节点移动。

我们可以发现这样就可以规避所有的冲突情况。

## 6. Social Justice

先按照 $a_i$ 排序。

显然最优的方案是选择一段区间。

考虑找到所有的最小的合法区间，然后区间内的元素将被保留。

但是这样会
```
wrong answer 470th numbers differ - expected: '9', found: '10'
```

因为最优解是区间不一定全部的合法解都是区间，可能有一些解包含包含某个元素，但是在所有的合法区间解中找不到这个元素。

因此我们只需要考虑形如 $i\cup R$ 的解，其中 $R$ 是一段区间。

由于最优解的长度已经确定，所以实际上只有 $O(n)$ 个合法的 $R$。

考虑如果 $i$ 在 $R$ 左边，则我们希望找到 $a_r\le K\cdot\dfrac{s_r-s_{l-1}+a_i}{r-l+2}$ 成立的 $R$，不难发现我们只需要求出 $a_r\cdot(r-l+2)/K-s_r+s-{l-1}$ 的最小值即可。

考虑如果 $i$ 在 $R$ 右边，则我们希望找到 $a_i\le K\cdot\dfrac{s_r-s_{l-1}+a_i}{r-l+2}$ 成立的 $R$，不难发现我们只需要求出 $\dfrac{s_r-s_{l-1}}{(r-l+2)/K-1}$ 的最大值即可。

那么如何求出最小的合法区间？固定 $r$，则我们需要找到使 $a_r\le K\cdot \dfrac{s_r-s_{l-1}}{r-l+1}$ 满足的最大的 $l$，可以用斜率优化之类的求出来。

## 7. Final Exam

做过了，但是当时没看懂。

问题相当于给出 $n$ 个分段二次函数，求出他们的 max-plus 卷积。

根据闵可夫斯基和的经典做法，我们可以考虑按照斜率排序，优先选择较大的斜率。

这里的二次函数我们可以看成无数段线性函数的拼接，我们仍然可以通过二分斜率的方式求出 max-plus 卷积的形状。

对于 $a_i>0$，我们要么选择 $x=0$，要么选择右半边的函数，所以要 $2^k$ 枚举。

## 8. Travel around China

同一场比赛，当时顺路看了这道题，也是聪明的。

我们先来考虑 $n=2$ 的情况，考虑分治。

考虑目前分治中心 $mid$，我们处理出以 $mid-1$ 结尾的所有最短路径和以 $mid+1$ 开始的所有最短路径，然后每次合并一下。

$n=3$ 类似。

## 9. Thanks to MikeMirzayanov

我貌似还真做过「原题」

考虑相邻合法对，因为这样的对一旦出现就不会拆开，可以看作缩点。

我们发现一次操作会使一个区间的 $r$ 与上一个区间的 $l$ 相连。

因此我们每次找到所有的相邻逆序对，然后尽可能地使他们合并。

## 10. Excluded Min

这个操作相当于可以把它均摊倒开，我们相当于找到最大的 $x$ 满足区间内 $< x$ 的数量至少有 $x$ 个。

但是问题来了，这个问题不一定满足单调性，因为比较小的 $x$ 也可能不合法。

考虑维护前缀和减去 $x$，然后我们相当于查询 $\ge 0$ 的最大位置。

然后不难主席树维护。

## 11. Best Subsequence

注意到序列中的最小值一定会被选，所以我们可以固定它做起点。

二分答案，根据一个经典的套路，我们可以把序列中的元素分为 $\le W/2$ 和 $>W/2$ 两部分。

我们知道

- 两个 $\le W/2$ 的元素一定能匹配
- 两个 $>W/2$ 的元素一定不能匹配

我们基础的答案即为 $\le W/2$ 的元素的个数，然后每两个 $\le W/2$ 的元素之间可以夹最多一个 $>W/2$ 的元素，且要求这个元素与两边都能匹配。

但是有多组询问怎么搞？

考虑整体二分。

如果我们知道整个序列的这个答案的形态，然后对于一段区间的答案，我们找到左侧第一个 $\le W/2$ 的元素 $i$，和右侧第一个 $\le W/2$ 的元素 $j$，然后在 $[l,i)\cup (j,r]$ 之间找一个 $\le W-\max(a_i,a_j)$ 的元素即可，这里可以用一个 ST 表找最小值。

## 12. Binary Search Tree

哦哦确实做过，很聪明。

首先这个区间插入很难搞，我们考虑把所有的操作和询问离线下来扫描线，对于区间插入 $[l,r]$，我们只需要在 $l$ 时插入这个结点然后在 $r+1$ 时删除即可。

为了不丢失时间的信息，我们需要在插入结点时记录一下时间 $t$，查询时只考虑时间 $<t$ 的结点。

不难发现我们的 BST 在考虑 $(w,t)$ 时实际上形如一个笛卡尔树，其中 $w$ 为 key，$t$ 为 priority。

因此在只考虑祖先信息的情况下，只保留 $<t$ 的结点和什么都不做其实都是一样的。

然后问题就变成动态维护笛卡尔树，查询祖先树链信息。

这个东西有点复杂，但是我们发现祖先树链信息只要查看左侧的后缀最小值和右侧的前缀最小值即可。

然后你发现这个东西就是兔队线段树的板子，这样就做完了。

## 13. Game

也做过。

考虑记从 $i$ 开始的最优期望得分为 $f_i$。

则我们知道 $f_1=A_1,f_n=A_n$，对于 $1<i<n,f_i=\max\{A_i,(f_{i-1}+f_{i+1})/2\}$。

有点抽象，我们不妨把 $\max$ 重写为不等式，然后尝试找到下确界。

则 $f_i\ge A_i,2f_i\ge f_{i-1}+f_{i+1}$。

注意到右边的不等式实际上意味着 $f$ 是一个凹函数，这是显然的，因为在中间的时候得分肯定比较多。

所以我们求出 $\{(i,A_i)\}$ 的凸包即可。

## 14. Local Maxima

为什么题目要求你只有恰好一个全局最大值？因为至少有一个全局最大值，那就是 $nm$。

考虑从大到小加入元素，那么除了第一个元素 $nm$ 以外，我们要求每个元素加入时，它的行或者列都至少已经有一个元素已加入。

这个怎么刻画 DP 状态？

注意到一个状态转移到下一个状态的形态只与他的不同的行和列的数量有关。

记 $f_{i,x,y}$ 表示目前加入了后 $i$ 个元素，且这些元素占据 $x$ 行 $y$ 列，则
- $f_{i+1,x+1,y}\gets y(n-x)\cdot f_{i,x,y}$
- $f_{i+1,x,y+1}\gets x(m-y)\cdot f_{i,x,y}$
- $f_{i+1,x,y}\gets (xy-i)\cdot f_{i,x,y}$

注意到这个东西形如一个带标号计数体系。

- $g_{x+1,y}\gets (n-x)\frac{y}{x+1}\frac{((x+1)y-1)!}{(xy-1)!}g_{x,y}$
- $g_{x,y+1}\gets (m-y)\frac{x}{y+1}\frac{((y+1)x-1)!}{(xy-1)!}g_{x,y}$

## 15. 100 Boxes Per Hour...

貌似在哪里做过类似题目。

考虑分类讨论，不妨让 $A>B>C$，如果 $B+C\ge 43$，则怎么放都行，只要不舍弃即可。

否则，我们知道 $A\ge 58$，$C\le 21$

我们还有一种简单的策略：对于每种颜色，把前 $C$ 次出现都丢弃掉，这种情况合法如果 $100-3C\ge 43$，即 $C\le 19$。

对于剩下的情况，考虑一种贪心的想法，对于每个颜色，能放就放，否则找到数量最少的一堆，如果这一堆 $<43/2$ 就清空这一堆，否则舍弃。

## 16. Designing a PCB

相当于把所有的颜色分为两组，使得每一组内部都不存在交叉。

考虑在两个交叉颜色之间连边，然后判断是否是二分图即可。

## 17. Knowledge Is...

讲个笑话：一开始没看到「Also, students are not very interested in hard work, so each student will work on a maximum of two projects.」然后想了半天。

相当于给区间做匹配，匹配的数量越多越好。

考虑反悔贪心。

发现如果某个可以跟他匹配的元素在跟一个 $r$ 比他小的元素匹配的话，把那个元素踢掉换成他不会更劣。

所以我们按照 $r$ 排序，这样就做完了。

## 18. Lights On The Road

考虑题目实际上可以转化为一个 DAG 最短路问题，有边

- $i\to i+1$，费用为 $a_{i+1}$
- $i\to i+2$，费用为 $a_{i+2}$
- $i\to i+3$，费用为 $a_{i+3}$

考虑从后往前递推，在最短路 DAG 上用左偏树或者线段树合并维护所有可能的路径差分，然后用优先队列在堆上选出前 $K$ 个即可。

## 19. Koosaga's Problem

考虑奇环，但是我们怎么找到图的全部奇环呢？

考虑建出一棵生成树，用环基生成所有环。

考虑异或哈希，对于每条环上的边都打上同一个异或，不同的树边打不同的标记。

则图是一个二分图，当且仅当总的异或和为 $0$。

判断 $|S|=1$，只需要看一下总的异或和是否与某条边的异或和相同。

判断 $|S|=2$，只需要看一下是否存在两条边异或起来与总的异或和相同，枚举一条边即可。

## 20. Rhythm Game

$C_j\ge C_{j+1}$ 很不符合常识啊……这不是在鼓励不连击吗。

虽然不符合常识，但是符合四边形不等式。

记 $f_{i,j}$ 表示前 $i$ 个音符总共 hit 到 $j$ 个，且 $i$ 恰为一次 combo 的末尾，的最高得分。

然后你发现他是一个离线决策单调性，可以用 LARSCH 解决。

## 21. Stone Catch Game

我们考虑如果 Platina 只有一块石子。

那么 Platina 能够获胜当且仅当 Yuto 一直往上走或者一直往右走的情况下都不能逃脱。

对于多颗石子，其实只需要保留最多两颗，一颗用来抓向上走，一颗用来抓向右走。

## 22. Setting Maps

如果 $K=1$，则拆点之后，问题为最小割。

考虑分层图，每一层的入点向下一层的出点连一条流量无穷大的边。

## 23. How to Move the Beans

首先不同的豆子显然是独立的，所以我们算出来 SG 的异或即可。

由于题目已经强行给我们设定了一个 DP 状态了，我们不妨从下到上，设 $f_{i,j}$ 表示从 $(i,j)$ 出发的 SG。

然后在每一行内，你一旦选择一个方向就不能走回头路，选择一个位置进入下一行。

记 $g_{i,j}$ 表示从右边过来且目前走到 $(i,j)$ 的 SG，$h$ 是从左边过来，则

$$
g_{i,j}=\operatorname{mex}\{f_{i+1,j},g_{i,j-1}\}\\
h_{i,j}=\operatorname{mex}\{f_{i+1,j},h_{i,j+1}\}\\
f_{i,j}=\operatorname{mex}\{g_{i,j-1},h_{i,j+1},f_{i+1,j}\}
$$

但是这样可能会出错。因为我们可能走到原来的位置。

如果当前行存在 `#`，则他是可以顺序转移的，我们可以快速计算出来答案。

否则，我们得设 $g_{i,j,k}$ 表示走了 $k$ 步的结果，$h$ 同理，然后

$$
g_{i,j,k}=\operatorname{mex}\{f_{i+1,j},g_{i,j-1,k+1}\}\\
h_{i,j,k}=\operatorname{mex}\{f_{i+1,j},h_{i,j+1,k+1}\}\\
f_{i,j}=\operatorname{mex}\{g_{i,j-1,0},h_{i,j+1,0},f_{i+1,j}\}
$$

这个东西怎么算呢？你发现你相当于每次从一个位置开始按顺序 $\operatorname{mex}$ 上 $f$，所以实际上我们可以用**倍增**或者简单地线段树计算出 $g_{i,j-1,0}$ 和 $h$。然后就做完了。

## 24. Interesting Coloring

考虑建生成树，我们令这条特殊的 bypass path 即为环基。

如何给树染色？考虑维护走到 $u$ 时根到 $u$ 的路径使用的颜色集合 $C$。

考虑一个拓展的树链剖分，对于 $u$ 的所有儿子，按照子树大小排序，对于前 $|C|$ 个使用 $C$ 中颜色，否则使用新颜色。

对于返祖边，我们可以给他随便赋一个在两个端点处都没有出现的颜色。

可以证明这样使用的颜色数量不超过 $8$。（其实我不会证

……是真的，我发现碰到无向图上环的问题，不是生成树环基就是圆方树，没有别的算法了（最多算上耳分解之类的双极定向）

## 25. Joy with Permutations

怎么又是做过的题（？

考虑如果 $n=4$，只使用操作 $1$ 得到的信息。不难发现我们永远也不可能知道他是顺序的还是逆序的，只能知道一个方向不确定的排列。

考虑询问 $i,j,k$，不妨假设得到的中位数为 $j$。

考虑再询问 $j,k,l$，

- 如果得到的中位数为 $j$，则我们知道 $i,l$ 一定在 $j$ 的同一侧，此时再询问一次 $i,j,l$ 即可知道哪个元素更靠近 $j$，得到 $k,j,i,l$ 或者 $k,j,l,i$
- 否则，如果得到的中位数为 $k$，则直接得到 $i,j,k,l$ 的顺序。
- 否则，如果得到的中位数为 $l$，则直接得到 $i,j,l,k$。

考虑拓展这个过程，发现形如每次把一个元素插入到原先的空隙中，直接二分查找即可做到 $O(N\log N)$ 次查询。

这个时候我发现自己看错题了，回答的是中位数的**值**而非编号。

如果是编号的话，从信息论的角度就是不可能的（因为基于比较的排序的时间复杂度是 $\Theta(N\log N)$。

我们问出来 $a_1,a_2,a_3,a_4$ 的顺序，不妨假设 $a_i<a_j<a_k<a_l$，我们问若干次知道 $a_j,a_k$ 的值，设为 $L$ 和 $H$。

我们维护最小的两个数和最大的两个数，并维护次小值和次大值。

每次加入 $a_x$ 时询问 $a_i,a_l,a_x$：

- 如果 $x<L$，那么可能是 $a_x$，也可能是把 $a_i$ 给问出来了。但是我们不用管它，我们只需要知道一套这个东西就行了，所以有了 $(i,x,k,l)$，$L\gets$ 新的返回值
- 其余也类似。


## 26. Lazy Judge

交互，懒得做了

## 27. AND Permutation

即 $A$ 是一个关于子集关系的闭包。

考虑按照最低位为 $0/1$ 分类，则要求 $1$ 之间不能匹配。

我们知道对于每个 $1$ 他都有一个对应的 $0$。

首先我们递归求出 $0$ 和 $1$ 去除这一位之后内部的匹配情况。

对于每个 $1$，我们知道他去除这一位之后的匹配情况再加上 $0$ 之后一定在 $0$ 中，所以就跟他匹配。

对于每个 $0$，如果他的匹配对象加上 $1$ 之后在 $1$ 中，就跟这个 $1$ 匹配；否则跟加上 $0$ 后的匹配对象匹配。

这样就能做到不重不漏地匹配

## 28. Permutation CFG

考虑这个东西，记 $f_i$ 表示 $i$ 的出现次数，然后一次展开就相当于做一次后缀和，可以用一个二项式系数算出来大小。

预处理 $\le s$ 次展开的在原排列的前缀和，每次二分确定位置进入即可。

## 29. Special Cycle

考虑所有特殊边生成的子图，如果存在环直接就有答案，否则构成一个森林。

考虑每个连通分量，不难发现如果我们希望选择至少一条边，就会把整个连通分量选完，而且合法要求这个连通分量本身就是一个路径。

我们先删除掉所有不合法的连通分量的点。现在我们希望使用不在任何连通分量内的点把剩下的连通分量串起来，而且还不能重复使用。

首先我们先把路径压缩成一条边，就形成了一个新的原问题，但是我们知道每个特殊边都没有共点。

然后你发现只要让每个点的度数都为 $0$ 或者 $2$，且如果一个点有特殊边，且度数不为 $0$，则一定需要包括这个特殊边。

考虑构造 $G'$，使 $G'$ 中的一个完美匹配对应 $G$ 中的一个解。

## 30. The King's Guards

定义独立集为

- 图拟阵的独立集，即生成森林
- 存在一个匹配方案，使得每个连通块都至多只有一个 guard

我们来证明它是一个拟阵:

- 非空性：当然此题不一定满足，但是如果 $\varnothing$ 是不合法的，那他一定不存在合法解。
- 遗传性：显然满足。
- 扩张性：对于 $I,J\in \mathcal J$，如果 $|I|<|J|$，且 $J$ 极大。则必然存在，$I$ 中的一个连通块在一个匹配方案中没有 guard。如果这个连通块不在 $J$ 中，则一定存在边连接这个连通块与别的连通块。显然连一下仍然是合法的。否则，我们可以通过交错路径发现另一个合法的连通块。

然后我们把边集排序，每次加入边时做一下二分图匹配判断一下是否合法即可。

## 31. Joke

先看一下怎么快速求 $f(p,q)$。考虑对一个 $s$ 合法的条件。

首先不妨假设 $p=1,2,\dots, n$

显然只要不存在有向环就行，即不存在 $s_i=1,s_j=0,i<j,q_i>q_j$。

那么对于每个 $i$，要么 $s_i=0$，要么对于所有 $i<j,q_i>q_j$ 的 $s_j=1$。

考虑 DP。记 $f_{i,j}$ 表示前 $i$ 个里面填了 $s_i=1$ 的 $q_i$ 的最大值 $=j$，的方案数。

对于 $q$ 不确定的情况也差不多。

## 32. K-onstruction

构造题。

考虑放 $a$ 个 $x$ 和 $a$ 个 $-x$，则会产生 $2^a$ 的贡献（算上空集）。

然后我们随机选 $x$，那么大概率不会发生冲突，导致相互影响。

然后直接二进制拆分即可。

## 33. Cactus

注意到 2 操作可以翻转所有点的度数的奇偶性，所以我们一定是删到不能删再做 2 操作。

我们考虑如果不进行 2 操作的最优结果。

显然最优的点是

- 他本身是奇点；
- 他的邻居都是偶点。

直接在一般图上考虑有点困难，但是好在这道题是仙人掌。

如果是一棵树，注意到直接每次删叶子（度数为 $1$）的点就是最好的。

在仙人掌上，我们仍然可以找到所有奇点，然后剥掉它。可以发现剩下来的都是一些环。

然后我们使用一次 2 操作，最后我们发现所有的边都能被删除！

## 34. Hamiltonian Path

显然一个必要条件是 $\gcd(p,q)=1$。

观察样例，我感觉唯一的合法解就是每次跳到跳不了为止，然后转弯。

然而第二个点就 WA 掉了……

实际上的路径是每一步能减 $q$ 就减 $q$，否则加 $p$，这样可以构造出一个 从 $0$ 跳到 $q$ 的长度为 $p+q$ 的哈密顿路径。

如果 $(p+q)|n$，直接就得到了一个构造。但是只有这样是合法的吗？不尽然。

如果 $(p+q)|(n-1)$，其实也可以，最后一步跳到那个点，没有跳满。

如果 $(p+q)|(n+1)$，其实也可以。我们可以看作删掉了起点，直接从第二步开始跳。

还有两种特殊情况：如果 $p=1$ 或者 $q=1$ 不难构造特殊解。

然后就做完了。

## 35. Goldberg Machine 2

ああ……我也头痛啊

太厉害了这道题

考虑刻画一个 token 移动过程中的**不变量**，它满足

$$
P(B)=T(t)+\sum_c B_c A(c)
$$

对于所有 token 的位置 $t$ 不变。

其中 $B$ 表示一个棋盘状态，$c$ 对所有的格子枚举，$B_c=0/1$ 表示 状态 $B$ 中格子 $c$ 的值，不妨假设 $B_c=1$ 当且仅当格子向右走。

$T$ 与 $A$ 都仅与 $c$ 这个位置有关。

则我们发现

$$
T(x,y)+A(x,y)=T(x,y+1)\\
T(x,y)=A(x,y)+T(x+1,y)
$$

这意味着

$$
T(x,y)=(T(x,y+1)+T(x+1,y))/2\\
A(x,y)=(T(x,y+1)-T(x+1,y))/2
$$

我们可以对每个网格外的格子设一个 $T(c)=x_c$，然后就可以把所有网格内的格子写成所有 $x_c$ 的线性组合。

然后我们发现 $P(B_1)\equiv P(B_2)\pmod 1\iff B_1=B_2$。

因为只有 $2$ 的负数幂次是重要的。

记 $B+k$ 表示 $B$ 放了 $k$ 次 token 之后的状态。

则我们发现 $P(B+k)=P(B)+k\cdot T(c_0)$，显然。

于是我们的答案就是 $(P(B_1)-P(B_2))/T(c_0)\pmod {2^p}$，其中 $2^p$ 表示 $T(c_0)$ 系数中的最大分母。

当然直接做一个 $n$ 元多项式除法是不可能的，我们可以给他随机赋几个整数，多试几次，然后找到分母的最大值作为 $2^p$。

## Nein

Nein Nein Nein

梦回小学奥数

$x(10^k-1)=10^kx-x$。

显然 $x>10^{k-1}$，不然第 $k-1$ 位就变成 $9$ 了，但是貌似没什么用。

---

考虑记 $M=10^k-1$，则 $10^k\equiv 1\pmod M$，换句话说 $x\bmod M$ 可以通过每 $k$ 位拆一段加起来计算。

那么所有的 $x\cdot M$ 又意味着什么呢？意味着所有每 $k$ 位拆一段加起来同余于 $0$ 的数。

首先我们先知道答案总共用了多少段。

假设使用了 $> l$ 段，则要求 $[z^0](\sum_{i=0}^M [9\notin i]z^i)^l<n$，其中 $z$ 是模 $M$ 的循环群加法卷积。

这个怎么算呢？注意到他其实不会超过 $z^{lM}$ 所以可以先转成一般加法卷积。

然后不会了

## MIPT: Connecting People

MIPT 有 $60$ 栋 $3\ 000$ 层的摩天大厦，而世界第一的高塔哈里发塔只有区区 $163$ 层……

考虑按 $h$ 排序从大到小加入，则任意时刻能够相连的都只有相邻点。

考虑 $tv$ 对答案的贡献，发现他只取决于 $i$ 修建走廊的位置，不妨设 $v_{i,j}$ 表示 $i$ 在高度 $j$ 修建走廊的代价。

考虑 $th$ 对答案的贡献，不难发现系数即为两边的 $\sum h$ 的乘积。

以 $1$ 为根，注意到任意一个子树都必然形如一个区间。

所以做一下区间 DP 即可。

## 38. Mission Impossible: Grand Theft Auto

首先第一步肯定是选直径。

然后我们从两边向中间，每次匹配掉两个叶子，这样就是对的。

## 39. Edit

注意到这个操作不会改变 DFS 序的连续性，所以一定是树 1 的一段区间对应树 2 的一段区间。

然后做一下区间 DP 即可。

## 40. Hamilton Path

注意到起点只有一条出边，枚举起点，就能找到第二个点，而且这个第二个点在去掉指向起点的边之后也只有一条出边……因此只要确定了起点就只有最多一个解。

但是 $n$ 比较大，暴力模拟过不了。

考虑强连缩点，则跨越 SCC 的边是一定要选的，因此合法当且仅当强连缩点之后形如一条链，我们可以对每个 SCC 分别处理。

首先如果有不止一个 SCC，则每个 SCC 要么确定了起点要么确定了终点要么都确定了，此时可以跑上面的暴力得到一个唯一解。

因此棘手的情况是图形如一个 SCC。

注意到对于每个有向环都有且仅有一条边不被选。

## 41. Link Cut Digraph

直接做好像有点困难，但是我们可以考虑离线。

我们希望求出对于每条边，他第一次加入 SCC 的时间。考虑**整体二分**。

每次加入 $[l,mid]$ 内的边跑 tarjan，然后把在 SCC 的边扔进 $[l,mid]$，否则扔进 $[mid+1,r]$。

## 42. Juggler's Trick

如果颜色都已经确定怎么做？

我们可以证明只要红球的数量 $R$ 和蓝球的数量 $B$ 满足 $R:r=B:b$ 就一定能全部删完。

证明：把数列每 $r+b$ 分一段。则必然存在相邻两段满足其中一个 $R$ 比较多 而另一段 $B$ 比较多。

考虑移动这个区间，然后每次红球的数量最多减 $1$，所以必然存在一个位置恰好为 $r$。

然后就能数学归纳证明必然有解。

然后可以 DP

## 43. Lion and Zebra

TODO

## 44. AND PLUS OR

又有交又有并很难搞。

考虑记 $x=i\cap j,y=i\backslash j,z=j\backslash i$，则 $a_{x\cup y}+a_{x\cup z}<a_{x}+a_{x\cup y\cup z}$，要求 $x,y,z$ 两两不交。

或者等价地 $a_{x\cup y}-a_x<a_{x\cup y\cup z}-a_{x\cup z}$。

也就是我们找到所有差为 $y$ 的二元组的差中存在包含关系且不同的二元组即可。

注意到「包含关系」是一个偏序，实际上我们可以约束得更紧。

因为如果存在 $u\subseteq v$ 使其不同，那么必然存在 $u\subseteq w,w'\subseteq v$ 使 $w\cup\{z\}=w'$ 两者不同。

但是直接这样做还是 $O(3^n\mathrm{poly})$ 的。

不过我们这样做证明 $z$ 取 $|z|=1$ 不会更劣，实际上 $|y|=1$ 也不会更劣。

然后就是 $O(2^n\mathrm{poly})$

## 45. Curly Racetrack

考虑对棋盘黑白染色。

然后相当于二分图最大匹配，最大化匹配两次而且没有被 ban 的点的个数。

## 46. Maximal Subsequence

考虑网络流：

记 $l_i$ 表示以 $i$ 为开头的 LIS 长度，$r_i$ 表示以 $i$ 为结尾的 LIS 长度。

记 $M=\{i|l_i+r_i-1=L\}$，建图

$$
V=\{S,T\}\cup\{i_{in},i_{out}|i\in M\}\\
E=\{(S,i_{in},1)|l_i=1\}\cup \{(i_{out},T,1)|l_i=L\}\cup \{(i_{out},j_{in})|l_i+1=l_j,a_i<a_j\}\\
G=(V,E)
$$

则答案即为 $G$ 的最小割。

可以用模拟网络流解决。

## 47. Lucky Tickets

实际上我们连数合法数组的数量都做不到，所以一定是有可以抵消的部分的。

贡献的前半部分跟后半部分一点都不搭，考虑能否分别统计分别抵消。

对于前半部分，考虑拆乘法组合意义，则相当于对于所有合法数组的任意一个子集 $S$，其贡献为 $\overline S$ 的乘积。

由于合法性与 $a$ 的顺序无关，所以我们可以看作对于所有大小为 $k=q-|S|$ 的集合的乘积求和。

记这个值为 $f(n,k)$，则 $f(n,k)=f(n-1,k)+f(n-1,k-1)\cdot n$，不难发现 $f(n,k)={n+1\brack n+1-k}$。注意到 $f(n,k)\equiv [k=0]\pmod n$。

因此我们只需要考虑 $S$ 为全集的情况，也就是第一项直接就是 $\prod a_i$。

考虑第二项，同样对 $a_i$ 开始不做区分。

考虑如果 $a_i$ 出现了 $c_{a_i}$ 次，则加起来等于

$$
\sum_{i=0}^{q-1}(2^q-1)\cdot\binom{q-1}{c_0,c_1,\dots,c_i-1,\dots,c_{q-1}}
\equiv \binom{q}{c_0,c_1,\dots,c_{q-1}}
$$

（使用了费马小定理）

注意到由于 $q$ 是**质数**，所以除非存在 $c_i=q$，即全部相同的情况，否则上式直接等于零。

因此对于第二项，我们只需要统计元素全部相同的情况。

现在我们回到第一项，你发现此时它的贡献与 $a$ 的顺序无关，因此它也是会贡献 $\binom{q}{c_0,c_1,\dots,c_{q-1}}$ 次，所以我们只需要考虑元素全部相同的情况即可！！

实际上第一项可以直接忽略掉了，因为如果全都是 $i$，那么会直接在 $-i\bmod q$ 那一项直接清零。

TODO

## 48. Soccer Match

~~全划成观众不就行了~~

首先对于度数 $\le K$ 的点可以直接删了，然后这样连环删点。

然后直接随机拓展，如果发现不合法就调整法。

## 49. Gachapon

玩原玩的😅

设 $f_{k,j}$ 表示一次随机 $k$ 级抽卡合法且抽到的星级最高的卡是 $j$ 的概率。

则 $\forall j\ge k$：

$$
f_{k,j}=f_{k-1,\le j}^{b_k}-f_{k-1,<j}^{b_k}\\
f_{0,j}=\frac{a_j}{\sum_{i=1}^na_i}
$$

然后 $p=f_{n,\ge n}$

考虑怎么算期望。

考虑**倒着 DP**。

记 $g_{k,j}$ 表示已知某个 $k$ 级抽卡合法且最高星级为 $j$ 的情况下，$n$ 级抽卡合法的概率。

初始时，我们有 $g_{n,n}=g_{n,n+1}=\dots=g_{n,m}=1$

然后
$$
g_{k-1,j}=\cal{TODO}
$$

## 50. Build a City

怎么又是做过的？还是弱化版

记 $f_{i,j}$ 表示使城墙右侧 $x$ 坐标为 $i$，$y$ 坐标为 $j$ 的合法性，初始时 $f_{x,y}=[x+y\le m]$

则加入点 $(x,y)$ 时：

- 若 $x>i,y\le j$，$f_{x,j}\gets f_{i,j}\land [j+x-i\le m]$
- 若 $x\le i,y>j$，$f_{i,y}\gets f_{i,j}\land [i+y-j\le m]$

对于剩下两种情况我们都可以不予考虑。

不难扫描线解决。

## 51. Kilk Not

考虑二分答案，然后对于去掉问号之后的每个 $0/1$ 连续段可以分别考虑，用一个 DP 记一下夹在中间的问号的状态即可。

## 52. Angle Beats 2.0

这种题首先考虑图论建模

我们称一个「策略」为对于每个 `*` 的 UL、UR、DL、DR 之一。

则

- 对于每个 `*` 必须恰好选择一个「策略」
- 对于每个 `.`，至多被一个「策略」覆盖

也就是要求这个三分图度数至多为 $1$。

## 53. Good Coloring

考虑按照颜色编号从小到大给图定向，把它变成一个 DAG，然后找到最长链，注意到这条链上颜色是严格递增的，而且一定不存在「支链」比他长，所以可以重标号之后合法。

## 54. Balance

移项发现 $A[i][j]-A[i+1][j]=A[i][j+1]-A[i+1][j+1]$。

令 $A'[i][j]=A[i][j]-A[i+1][j]$，则 $A'[i][j]=A'[i][j+1]$，即每一行的列差分相同。

记 $b_i$ 表示 $B$ 在第 $i$ 行的列差分，$c_i=B[n][i]$，$s_i=\sum_{j=i}^{n-1}b_j$，则

- 合法当且仅当 $s_i\ge \max_j \{A[i][j]-c_j\}$，$c_j\ge A[n][j]$
- 最小化 $n\cdot \sum_{i=1}^{n-1} s_i+n\cdot \sum_{i=1}^n c_i$

考虑 $A[i][j]\gets A[i][j]-A[n][j]$，即可归为 $c_j$ 从 $0$ 开始的情况。

直接贪心选即可。

## 55. Gravity

模拟即可。放过来是因为太有趣了吗？

## 56. Qnp

直接康托展开即可。

## 57. Taxi

考虑 $dis(u,v)=dep(u)+dep(v)-2\cdot dep(LCA(u,v))$，则我们只需要考虑 $LCA$ 怎么选。

注意到只有 $A$ 和 $B$ 都存在绝对众数，且绝对众数都在一个子树内的时候，才不能匹配完。

然后可以每次递归进去。

现在考虑如果放置的不确定怎么办？

首先 $dep(u)+dep(v)$ 这一项是容易处理的，对于 $dep(LCA(u,v))$ 这一项，我们枚举是否存在绝对众数，以及绝对众数在哪里，以及绝对众数的大小，即可进去。

再推一下式子应该就能算出来。

## 58. Ternary Search

有趣的结论：

考虑单谷序列，则一个元素贡献的「逆序对」即为左侧比他小的元素与右侧比他小的元素的最小值，这是显然的，因为他要么跟左边的比他小的元素交换；要么与右边的比他小的元素交换。

单峰序列同理。

这个用线段树维护即可。

## 59. Grammy Sorting

笑点解析：一开始看成必须选择从 $A$ 到 $B$ 的路径，想了半天。

首先把它定向为 DAG，可以任意钦定一个拓扑序作为最终答案。如果不止一个源点或者不止一个汇点，则无解。

先弄出来一个生成树，不难发现我们只需要考虑树上的边即可。

考虑从每个叶子开始，用类似插入排序的方式，先把要插入的元素放到 $A$，然后一次插进去。

## 60. Great Party

结论：先手必胜当且仅当

- 堆数为奇数。
- 每堆的数量减去 $1$ 之后的异或和不为 $0$。

至少满足其一。

反之，必败当且仅当堆数为偶数且减一异或和为 $0$。

证明：

为什么有一个奇怪的减一？

我们考虑把操作分为两类：

- 对一个 $a_i\gets a_i-t$，且 $0<t<a_i$
- 取走一个 $a_i$，并选择一个 $a_j\gets a_j+t$，且 $0\le t<a_i$

不会。博弈论，太困难。

## 61. Easy Problem

我们先不管那个坑，则我们可以按 $r$ 从小到大排序，然后贪心匹配。

实际上我们还有另一个策略：按 $l$ 从大到小排序，贪心匹配。

考虑扫描线，我们从左到右扫，然后以隐式的方式进行按 $l$ 从大到小排序的贪心，也即从右往左考虑每个元素，每个元素优先匹配 $l$ 最大的区间，同时，每个区间也优先匹配最大的元素。

考虑对每个区间维护它向 $i$ 右侧贡献了多少流，然后可以知道他在左边剩多少流。

每次加入 $l=i$ 的区间，不难发现他的优先级是目前全部区间中最高的，所以他可以让其他区间都给他让位置。

记 $w_i=\sum_{r_j=i}c_j-a_i$，则 $w$ 的最大的前缀和的最大值记作 $o$，则 $o$ 右边结束的区间都没有盈余，其流向 $o$ 右边，同时，从 $o$ 左边的任意一个区间中任意减少流都是可以的。

所以我们找到 $r\le o$ 的优先级最低的区间，然后从他那里拿流。复杂度是正确的。

## 62. Hard Problem

考虑 $k=0$ 的情况。

我们不妨从小到大加入 $a_i$，则我们一次性加入的若干元素会把原先的已加入连续段连接起来，只有此时连接起来的才是合法的区间。

考虑对于每个 $a_i$，他的贡献形如 $f$ 的一段区间和。

记他左边第一个新加入元素为 $p$，右边为 $n$，区间左端点为 $l$，右端点为 $r$，则他的贡献为
$$
\sum_{m=\max(i-p+1,n-i)}^{\min(i-l+1,r-i)}(a_i+10)f_m
$$

考虑 $p,n$ 之间的中点、$l,r$ 之间的中点，拆掉 min,max 之后，可以容易地计算区间贡献和。

如果 $k\ne 0$，那么每次把前面 $k$ 个也捞上来就行了，为了避免算重，我们还希望区间内至少要包含一个当前元素，也就是只有跨连续段（旧）的才记录在内。

fun fact：Hard Problem is easier than Easy Problem.

## 63. Battleship: New Rules

我们考虑线的交点，然后变成放若干 $2\times a$ 或者 $a\times 2$ 的不能重叠的矩形，找到一个 $1\times 1$ 的空地，一次可以检查是否一个 $2\times 2$ 的矩形被完全包含，同时 $n\gets n+1$。

记 $s$ 为完全被矩形包含的内点的数量，玩家 1 即要最大化 $s$。

记 $k$ 为矩形的数量，可以发现占领的总面积 $2(k+s)\le n^2$，因此 $s\le \lfloor n^2/2\rfloor-k$，可以证明这个上界是可以取到的。

因此如果 $n$ 为偶数，直接就输出 $-1$，因为允许完美覆盖。

否则，由于向下取整会制造恰好一个空格，我们的目标就是把它问出来。

考虑一种类似二分的思路。维护一个 $(x_l,y_l,x_r,y_r)$ 表示答案在这个矩形里，每次问一下中间的分界线上的所有矩形，如果找到就直接返回，否则我们可以知道两侧的奇偶性，只进入奇数的一侧即可。

## 64. Fast Bridges

首先由于这个桥不是很快，所以我们的策略一定是：

- 绝不兜远路。
- 最优情况下能经过多少条桥，就能让这个曼哈顿距离减多少。

注意到此时 $x_1<x_2,y_1<y_2$ 的点对和 $x_1<x_2,y_1>y_2$ 的点对和桥是互不影响的，可以分开处理。我们不妨假设只考虑 $x_1<x_2,y_1<y_2$。

考虑提取出所有 $O(n)$ 个特殊点，这些特殊点总共会把平面划分为 $O(n^2)$ 块，不难发现同一块与同一块之间的行为都是一致的。

由于连边形如 DAG，所以不难直接算出答案。

## 65. Building Bombing

首先如果你的 lab 已经是前缀最大值，则删除 $<L$ 的元素啥用也没有。

受到启发，我们记 $f_{i,j}$ 表示只考虑 $[i,n]$ 的元素时，使 $i$ 成为前缀最大值中的第 $j$ 大的最小代价。

转移时，考虑找到 $i$ 后面第一个前缀最大值 $x$，以及删除掉 $x$ 之后的第一个前缀最大值 $y$。则 $f_{i,j}=\min(f_{x,j-1},f_{y,j-1}+1)$。这个不难用主席树之类求出来。

然后就做完了？？

## 66. Routes

尽管看起来很简单，但是实际上这个应该不存在 $O(n+m+\operatorname{poly}(k))$ 的做法。

考虑怎样设计一个与 $k$ 的指数有关的算法。

在此之前，我们先发掘一些图的性质。

- 这个图由 $k$ 个团和 $m$ 条链组成。我们可以证明任意两点之间的距离不会超过 $2k-1$，显然。
- 记 $f(i,x)$ 表示从城市 $x$ 到区域 $i$ 中任一城市的最短距离，则 $dis(u,v)\le f(i,u)+f(i,v)+1$。
- 否则，我们一次热气球也不用。则 $dis(u,v)\le$ $u$ 和 $v$ 在铁路上的距离。
- 记 $g(i,j)$ 表示区域 $i$ 和区域 $j$ 之间的最短距离，则 $f(i,u)\le g(i,d_u)+1$。
- 这里 $f$ 和 $g$ 可以做 $O(k)$ 次 BFS 求出来，时间复杂度 $O(kn)$。

考虑枚举区域对 $(d_u,d_v)$，由于两个区域之间的距离最多只有 $3$ 种，所以只需要看一下 $u$ 到 $v$ 是允许直连/$u$ 或 $v$ 需站内中转/都需要站内中转。

对于直连的情况：此时 $dis(u,v)=g(d_u,d_v)$。

不会，弃了

<!-- 考虑对于每个区域对 ，和一个集合 $S$，我们找到所有满足 $dis(u,v)=f(i,u)+f(i,v)+1\iff i\in S$ 的 $(u,v)$ 的数量。 -->

<!-- 记 $mask_u$ 表示满足 $f(i,u)\ne g(i,d_u)+1$ 的 $i$ 的集合。 -->

<!-- 则上式成立当且仅当 $mask_u\cap mask_v\supseteq S$。*没看懂* -->

<!-- 由于显然是独立的，记 $cnt(A,S)$ 表示区域 $A$ 中 $mask_u\supseteq S$ 的 $u$ 的数量，这里用一个高维后缀和求一下。 -->

<!-- 然后这里乘一下就能得到答案。 -->

对于铁路距离：实际上由于 $2k-1$ 的限制，直接暴力更新两对是允许的。

## 67. One, Two, Three

我们考虑贪心匹配，维护前面最优情况下的 `A`,`C`,`AB`,`CB`,`AC`,`CA`,`ACB`,`CAB`,`ABC`,`CBA`,`ABCB`,`CBAB` 的个数。

- 如果加入 `A`，则
    - 如果前面有 `CB`，则匹配变成 `CBA`
    - 如果前面有 `CBAB`，则匹配变成 `CBA` 和 `AB`
    - 如果前面有 `CAB`，则匹配变成 `CBA` 和 `A`
    - 如果前面有 `ACB`，则匹配变成 `AB` 和 `CA`
    - 如果前面有 `C`，则匹配变成 `CA`
    - 否则，加入 `A`
- 如果加入 `B`，则
    - 如果前面有 `A`，则匹配变成 `AB`
    - 如果前面有 `C`，则匹配变成 `CB`
    - 如果前面有 `AC`，则匹配变成 `ACB`
    - 如果前面有 `CA`，则匹配变成 `CAB`
    - 如果前面有 `ABC`，则匹配变成 `ABCB`
    - 如果前面有 `CBA`，则匹配变成 `CBAB`
    - 如果前面有 `ACB`，则匹配变成 `AB` 和 `CB`
    - 如果前面有 `CAB`，则匹配变成 `CB` 和 `AB`
- `C` 的情况与 `A` 类似。

最终我们统计 `ABC`,`CBA`,`ABCB`,`CBAB` 的个数即为答案。

但是这是错的。

## 68. Lonely King

可以发现一条蓝边都不剩不会更劣，所以答案形如一个（边的）树链剖分的形式，然后答案就是每条链的链头乘以链尾。

记 $f_{u,j}$ 表示 $u$ 的子树内留的一个叶子为 $j$ 的情况下的最优答案，$g_u$ 表示不留的最优答案，则

$$
g_u=\sum_{v\in son_u}\min_j\left\{f_{v,j}+a_uj\right\}=\sum_{v\in son_u} f_v(a_u)
\\
\begin{aligned}
f_{u,j}&=\min_{v\in son_u}\left\{f_{v,j}+\sum_{w\in son_u,w\ne v}\min_{j}\left\{f_{w,j}+a_uj\right\}\right\}\\
&=g_u+\min_{v\in son_u}\{f_{v,j}-f_v(a_u)\}
\end{aligned}
$$

可以维护 $(-j,f_{u,j})$ 的凸包，每次二分切割即可求出 $f_v(a_u)$。

然后这个就是若干个凸包按位求 min。可以用李超树+线段树合并求出来。

## 69. Beautiful Sequence

显然波浪形是最优的。

我们考虑枚举一个分界线 $k$。对于 $\le k$ 的元素我们用来分隔，否则用来产生贡献。

那么合法当且仅当 $(\le k$ 的元素个数$)\ge$ $(>k$ 的颜色个数$)-1$。

然后产生的贡献就是 $>k$ 的元素个数。

## 70. Connect the Dots

如果我们把 $-\infin$ 和 $+\infin$ 连接起来，可以发现我们所求的实际上是一个凸多边形三角剖分（当然看成圆也可以），要求异色点连边

首先如果相邻点异色，则肯定可以连边。如果不同色就肯定连不了。这里我们把它也当成连了边不会对后面的算法造成什么影响。

考虑每次连边尝试连接 $i-1$ 和 $i+1$，然后就能把 $i$ 给删掉，用一个双向链表维护即可。

注意我们这样连不了边当且仅当

- 剩余的 $n$ 为偶数
- 只剩两种颜色，且奇数位和偶数位的颜色分别相同。

如何避免这种情况？考虑每次优先删掉出现次数较多的情况，然后这样就能尽量避免。

当然这样不能完全避免。然后后面就只能一次删掉两个点，然后就能删完。

## 71. Greedy Bipartite Matching

貌似是动态网络流板子。

每次我们只需要加入跨越 S 集和 T 集的边，我们可以证明这样做的均摊复杂度是对的。

## 72. Forever Young

考虑差分数组 $d_i=a_{i+1}-a_i$。

则一步操作可以：
- 把一个元素移到左边一格或者右边一格
- 增减 $d_1$

注意到第一种操作不改变差分数组的总和，考虑枚举第一种操作的次数，然后就能知道第二种操作的次数。

## 73. Sets May Be Good

看起来很 NP 难，但确实是可解的。

记 $x_i$ 表示 $i$ 被选，然后我们所求即为满足

$$
\sum_{(i,j)\in E,i<j} x_ix_j\equiv 0\pmod 2
$$

的方案数。

记邻接矩阵 $A$（严格上三角矩阵形式），则可以写成 $\bm x^⊤ A\bm x=0$ 的形式，即一个所谓二次型。

记 $k=\operatorname{rank}(A+A^⊤)$，则答案为 $2^{n-1}-2^{n-k-1}$。貌似需要一些高深的线性代数结论。

## 74. Counting Cactus

记 $c_S$ 表示把 $S$ 组织成一个简单环的方案数，特别的，$c_{\{i\}}=1$。这个是简单的

我们这里做一个很经典但是我不会的 trick。设 $\mathcal G(r,S)$ 表示我们要求所有的割点都 $\le r$ 的情况下，把 $S$ 中点组织为仙人掌的方案数。

初始，$\mathcal G(0,S)=c_S$。然后答案就是 $\mathcal G(n,[1,n])$。

考虑从 $r-1$ 转移到 $r$，即现在允许 $r$ 成为割点。那么割掉 $r$ 之后会分裂成若干个连通分量，且每个连通分量都携带 $r$。

那么 $\mathcal G(r)\gets \mathcal{G}(r-1)+x^{\{r\}}\exp \sum_{r\in S} \mathcal G(r-1,S)x^{S\backslash \{r\}}$

## 75. Fast Spanning Tree

傻逼 gpt 把 $\ge$ 翻译成 $\le$。

注意到使 $sa_i+sb_i\ge s_i$ 至少需要 $sa_i\ge s_i/2$ 或者 $sb_i\ge s_i/2$。

对于每个条边，我们只在其中一边集合权值和 $\ge s_i/2$ 的时候检查一遍，然后扔进优先队列里面，所以均摊复杂度是对的。

用一个可并堆维护尚未检查的边即可。

## 76. Grammarly

做过的，而且甚至放的还是 T1。

注意到一般情况下一个子串连出来的两条边都是不同的，除非这个串的周期为 1。

所以只要检查每个连续段即可。

## 77. Honorable Mention

做过的。

首先这个东西肯定是凸的，证明应该可以用网络流。

考虑 WQS 二分，把这个询问挂在每个线段树结点上，每次二分的时候可以分别去割每个线段树结点的凸包，再特别处理一下连接点的影响。

线段树上的凸包可以直接预先求出来。然后复杂度是两只老哥

## 78. Independent Set

交互题野蛮，传统题文明，，，

## 79. Anti-Plagiarism

记 $dp(u,x\to v)$ 表示能否把 T1 的 $u$ 子树和 T2 的边 $x\to v$ 方向的 $v$ 子树匹配，然后转移的时候跑一个二分图匹配即可。

## 80. Bit Component

显然合法要求存在 $2^{k}+2^{k-1}+1\le n<2^{k+1}$，不然最高位 $2^k$ 根本连通不了，$1$ 例外。~~但是这个结论貌似没什么用，因为根本不充要。~~

好吧其实是充要的。

这个结论启发我们可以只关注最高位的行径，然后类似格雷码那样归纳到下一位的构造。

首先我们可以构造一个合法的 $[1,2^k)$ 的排列，且以 $1$ 开头，以 $2^k-1$ 结束，这个不难像格雷码一样递归构造。

其中一个方法是：对于 $[1,2^{k-1})$，我们放格雷码，得到一个从 $1$ 到 $2^{k-2}$ 的序列。然后我们对 $k-1$ 的构造进行位的左右翻转，得到一个 $2^{k-1}+2^{k-2}$ 到 $2^{k}-1$ 的序列，对于剩下的 $2^{k-1}$，我们插在 $2^{k-1}+2^{k-2}$ 后面，显然还是合法的。

然后我们考虑 $n=2^k+2^{k-1}+1$ 的情况如何构造。

排列顺序如下

- $[1,2^k)$ 的排列，以 $1$ 开始，$2^k-1$ 结束
- $2^k+2^{k-1}+1$
- $2^k+[1,2^{k-1})$ 的排列，以 $2^k+1$ 开始，以 $2^{k}+2^{k-1}-1$ 结束
- $2^k$
- $2^k+2^{k-1}$

对于余项 $2^k+2^{k-1}+x$，我们附在 $2^{k-1}+x$ 或者 $2^k+x$ 后面都可以，显然不造成什么影响。

## 81. Jumping Lights

神秘

你注意到如果最开始只有一盏灯是亮的，那么呈现出奇偶闪烁的神秘状态。

我们考虑维护两棵树 $T_1,T_2$，其中 $T_1$ 是当前树的状态，$T_2$ 表示对 $T_1$ 再做一次 `2` 操作的状态。每次 `2` 操作将交换两棵树，并对 `T2` 做一些修改，使信息正确。

也就是说，我们考虑如何快速计算连续进行两次 `2` 操作。

考虑每个 01 交替分量和每个 1 分量，可以发现这都会使他们向外邻域扩张 2 格。

两个 1 分量撞上了会变成一个 1 分量；两个 01 分量撞上了可能会进化为 1 分量，或者变成一个 01 分量。

维护 01 分量形成的虚树和 1 分量形成的虚树，以及两两之间的距离，可以动态维护其形态。

## 82. Bulbasaur

显然如果只问一个 $f$ 可以跑最大流。但是这里过不了。

注意到 $k$ 很小，复杂度大概是 $O(n2^k)$ 左右，但是怎么做呢？

注意到题目要求每个点经过的流量为 $1$，我一开始没看到这个想了半天==

有多个询问还是很难算，考虑如果只询问 $f(1,n)$，则我们可以记 $g_i(S)$ 表示能否使最大流在 $i$ 层经过 $S$。这里我们不妨从右往左流。

注意到这个东西是一个拟阵，根据一个神秘的结论（拓展的 Hall 定理），我们称一个 $A$ 准合法，当且仅当存在 $B\subseteq N(A),|B|=|A|$，且 $B$ 合法；则 $A$ 合法当且仅当 $\forall S\subseteq A$，都满足 $S$ 准合法。

我们可以维护 $mg(S)$ 表示 $S$ 中最大合法子集的大小，则 $A$ 准合法当且仅当 $mg(N(A))\ge |A|$，然后就可以 $O(2^k)$ 判断。

考虑如何计算 $f(i,j)$。注意到对于一个固定的 $i$，$f(i,j)$ 随 $j$ 递增单调不增。

对于每个第 $i$ 层的子集 $A$ 考虑维护最大的 $j$ 使其准合法/合法，记作 $okr(A),gr(A)$，则 $gr(A)=\min_{S\subseteq A}okr(S)$ 显然成立。

对于 $okr$ 也可以类似地把上面的 DP 转写为最优化 DP（先把 $mg$ 的状态也拆了）。这样我们就算完了。

## 83. Cloyster

考虑询问中间行的全部元素，找到其中的最大值，然后询问最大值周围的元素中的最大值，不难发现这个最大值在哪边全局最大值就在哪边，因为他不可能再跨过来了。然后就做完了。

## 84. Different Summands Counting

答案为

$$
\begin{aligned}
&\left(\frac{\mathrm{d}}{\mathrm{d}z}\left[\frac{x^ny^m}{m!}\right]\prod_{i\ge 1}\sum_{j\ge 1}\frac{x^{ij}y^jz}{j!}\right)\circ 1\\
&=\left.\frac{\mathrm{d}}{\mathrm{d}z}\left[\frac{x^ny^m}{m!}\right]\prod_{i\ge 1}(\exp(x^iy)-1)z\right|_{z=1}\\
\end{aligned}
$$

当然不是这样算的。

首先考虑拆贡献，对于每个 $i$ 求出他在划分中至少出现一次的方案数。

我们先来关注**总的**方案数，不难发现这就一个插板法，也就是 $\binom{n-1}{m-1}$。

你发现由于这个插板法太漂亮，导致我们根本刻画不了内部的出现，所以考虑容斥，则答案为

$$
\sum_{i=1}^n\sum_{k=0}^{m}(-1)^k\binom{m}{k}\binom{n-1-ik}{m-1-k}
$$

由于 $ik<n$，所以直接做就可以做到 $O(n\log n)$，然而 $n$ 是惨绝人寰的 $10^{18}$……

交换求和，考虑后面这一坨

$$
\sum_{i=1}^n\binom{n-1-ik}{m-1-k}
$$

怎么算。把它视作关于 $n$ 的多项式，注意到他的次数是 $m-1-k$。所以可以直接拉插插出来。

然后就做完了。

## 85. Emerging Tree

好像做过？

首先注意到答案一定形如一个广义的 DFS 序，其中每棵子树的根节点允许插在任何地方（前序/中序/.../后序）

考虑倒序操作，相当于每次断掉一条边 $(u,v)$。

我们找到 $u$ 的所有祖先（包括自己），则要求 $v$ 所在的子树是最先遍历的/最后遍历的（这是同时选择的）。然后把 $v$ 子树独立。

树链剖分每次打标记判断一下即可。

## 86. Jaw-Dropping Set

题目有点搞

> 称一个子集 interesting，如果它是一个关于整除关系的反链。称它为 amazing，如果它是最长反链。称它为 jaw-dropping，如果它在所有最长反链中和最小。

人话：求整除关系的最长反链的最小元素和。

首先最长反链的长度为 $\lceil n/2\rceil$，这是由于后面 $\lceil n/2\rceil$ 必然不在一个链里面覆盖，而且取后面 $\lceil n/2\rceil$ 个元素即为一个合法解。

然而这是一个最大解。怎么得到最小解？

对于每个偶数，把它替换为除以二肯定不会有冲突。

对于每个 $x$，如果 $n/2<3x\le n$，则我们要么把 $3x$ 替换为 $x$，或者替换为 $2x$。

算了太神秘不做了

## 87. $k$-coloring

首先如果 $k=1$ 答案就是求一个欧拉路。

考虑 $k=2$，你发现在 DFS 生成树上按照欧拉序遍历一遍就是对的，对于非树边，可以访问一遍再退回来。此时一定是合法的。

但是这两个算法有什么共同点吗？？？

考虑 $k=3$。注意到如果图是一个欧拉图，那么我们可以每次折返一下当成 $k=1$。

你发现我们可以选若干个欧拉路径，满足两个相邻欧拉路径首尾之间的距离皆为 $2$。

考虑所有的奇度点，如果相邻距离为 $2$ 就可以把它们消掉，这样就做完了。

对于其余的情况其实也可以类似处理。

如果 $k$ 是偶数直接就赢了，否则可以消掉相邻距离为 $\le k-1$ 的非零偶数的奇度点做欧拉路径。

## 88. Three Vectors

智慧题

注意到 spj 很不可做，所以肯定解有神秘性质

考虑每个 $x_i$ 在三个向量中的**众数**，注意到对于任意两个 $x_i,x_j$，它们的众数**必然发生重叠**。

因此对于所有满足这三个向量的 2-CNF，由这三个向量的按位众数形成的向量也一定能满足。

然后你手玩一下就可以发现可以最多只满足这 $\le 4$ 个不同的向量，因为对于其他的情况必然与前面相同。

现在我们考虑如何使用这个很松的 $\lor$ 限制完成对这 $4$ 个向量的约束。

注意到 $(a\lor b)\land (a\lor\neg b)\iff a$，这样就可以处理这一位四个向量都相同的情况，我们可以把这样的位给直接删掉了。

对于剩余的情况，也就是说仅有一个向量满足与其余不同。

考虑记 $s_1,s_2,s_3$ 表示第 $1,2,3$ 个向量与其他向量不同的位。我们不妨假设全部都是突出来一个 $1$，否则可以在这一位前面多加一个 $\neg$。

我们考虑把 $s_1,s_2,s_3$ 内部连成一条链，连 $(\neg x\lor y)\land(x\lor \neg y)\iff x=y$。

然后对于每个链头，两两之间连 $\neg x\lor \neg y\iff \neg(x\land y)$。

然后就做完了，实际上不看这个众数也差不多。

## 89. Decorative Birds

韩国题怎么这么困难……不愧是东亚最卷的国家

考虑把这只鹅放到二维平面上，变成一个纵坐标为 $A_i$，横坐标为 $[T_i,T_i+L]$ 的线段。则一个鹅的集合可以被选，当且仅当没有线段被未选择的线段完全覆盖。

我们可以把剩下的线段看成一个**柱状图**，则我们可以统计所有的柱状图，然后未被柱状图完全覆盖的线段就是所选的线段，这样就一定是合法的。

考虑 DP。记 $f_{i,j}$ 表示在横坐标为 $i$ 处柱状图的纵坐标为 $j$ 的最大所选线段权值和。

直接考虑有点困难，但是注意到线段的长度都是相等的，所以很有性质。

...

## 90. Holes in Queue

二分答案可以做到 $O(qn\log^2 V)$。

记 $f^d(x)$ 表示进行 $d$ 次操作后位置 $x$ 的值。则

$$
f(x)=
$$

## 91. Build Well

首先如果存在一种不使用 $1$ 的方案，则已经得到了一个合法解。

完全背包的解的存在性可以用比特赛特或者发发踢。

注意到如果不满足这个，则我们必须使用 $1$，因此我们可以假设现在一定有 $1$。

如果存在 $\max b_i>w/2$，则可以得到一个合法解。

考虑这样一种解：首尾扣住恰为 $1$，其余部分全部填 $1$。不难发现这样的一组解恰好对应一个 $|S|$ 为偶数的 $\sum_{i\in S}(b_i-1)=w$ 的部分和。

当然不一定只扣住 $1$，比如扣住 $2$ 也是可以的，只要这相邻两个都至少有 $3$ 即可。所以合法的可能性很高！

## 92. Permutation Recovery

注意到对于一对 $(i,j)$，第 $i$ 列里有 $j$ 当且仅当第 $j$ 列里有 $i$，如果成立，则连一条无向边。

则我们得到一个 $2k$-正则图，但是可能有自环和重边，我们期望把边集分为 $k$ 个部分，使每个部分中每个点的度数都恰好为 $2$。

考虑每次剥掉若干个哈密顿环。注意到这个东西相当于每个点跟他的下一个点做匹配。

跑一遍欧拉回路把每条边定向，拆点跑二分图匹配，然后就能让 $k\gets k-1$。

由于剩下的还是一个正则图，不难发现一定会有解。

## 93. Split the Picture

极差的性质虽然没那么好，但是应该还是很好的。

记四个象限为 $pl,sl,pr,sr$，则 $x$ 固定而 $y$ 增大时，$pl,pr$ 增大，$sl,sr$ 减小。

大力分讨一下全部的几种情况即可。

## 94. Single-Crossing

我的 image 呢

如果我们钦定了 $X_1$，以他为单位排列重新排列，则可以发现逆序对不减。对于逆序对相同的，我们又要求他完全一致。因此至多只有 $n$ 种合法的排列。

注意到其实不需要非得让他是 $X_1$？

考虑原来的 $X_1$ 排列之后变为 $X_i$，然后对其他重新排列。

则对于每个逆序对 $i>j$，对于所有包含这个逆序对的排列，要么全部排在前面，要么全部排在后面。

而且我们统计对于每个逆序对，包含这个逆序对的排列的个数，则可以把所有的排列分成两组，使得每一组内，如果他包含一个出现次数较大的逆序对，则其他全部出现次数比他小的逆序对也都全部包含，而且逆序对也不能跨组出现。换言之，每组内的逆序对呈现单链包含关系。

首先依然是考虑按照逆序对数量排序。

考虑对于每个排列，对于每个逆序对，他前面包含这个逆序对的元素必然跟他一组，他后面不包含这个逆序对的元素必然不跟他一组。

然后其实随便找几个逆序对就能很好分组了？

## 95. Fractal Maze

首先这个东西形成了一个树状结构。

然后我感觉直接记搜就行了。

## 96. Interactive Primality

注意到如果 $x+y$ 为质数，意味着对于任意一个比较小的质数 $p$ 而言，$x\not \equiv -y\pmod p$。

考虑对于所有 $\le 53$ 的质数 $p$，求出 $x\bmod p$，然后我们就能 CRT 得出结果。

其实根据上面的式子直接随机问就行了

## 97. Slot Machine

做过增强版

考虑 DP。先写出来一个最朴素的 DP：任意时刻我们知道的信息就是「可能的解在哪个区间内」，因此设 $f[l,r,v]$ 表示已知解在 $[l,r]$，且当前的数字为 $v$ 时的最小操作次数。

注意到如果不考虑第一次询问，则 $v\in \{l-1,r+1\}$，所以这一维只用记一个 0/1 即可。

首先注意到这个 DP 满足区间包含单调性，因为缩减它严格增强了信息，所以我们考虑互换值域和定义域。设 $f[l,k]$ 表示能在 $k$ 次操作问出来的最大的区间 $[l,r]$，且此时 $v=l-1$；同理可记 $g[r,k]$。这样我们的状态数就对了。

如何优化转移？注意到这个转移一定是比较接近中间的位置，实际上可以证明对于代价相同的转移满足单峰，因为它是一个形如 $\min_m\{\max(f[l,m-1,m],f[m+1,r,m])+w(v,m)\}$ 的形式，两边都是单调函数，所以我们可以枚举代价三分出最优转移点。

对于第一次询问的位置，直接枚举即可。

## 98. Mausoleum

枚举钻的点在哪条线段上即可。

## 99. Protecting Kingdom

点分治板子。注意应当使用 $\sum k$ 而非 $\sum 1$ 以均摊复杂度。

## 100. Square Stamping

应该满足四边形不等式，所以直接每次转移同颜色的一段即可。

## 101. String Rank

首先注意到

$$
Q_t(s[1:])\supseteq Q_t(s[2:])\supseteq\dots\supseteq Q_t(s[n:])
$$

考虑子序列自动机，我们可以计算出对于每个后缀，长度至多为 $t$ 的子序列的个数，然后比较一下即可，这样可以做到 $O(n^2)$。

题解的意思貌似是 DP 求出最短的新增子序列长度，但是我没看懂正确性 =="

## 102. AmazingTalker

在 QOJ 随机刷题刷到过，就把总结复制过来了。

首先显然「互为师生」的关系是好的，我们优先选完这样的关系。

我们把问题聚焦到在前面没有连边的点上，我们决定给他找**一个**先生。

但是，一个先生有了过多的学生是不行的。

显然这些要找先生的学生，有两种决策，不妨记作 $x$ 和 $y$。

发现形如二分图匹配，考虑 Hall 定理。

每个学生向 $x$ 或者 $y$ 比他小的先生连边，我们已知每个先生最多允许的度数，求是否存在完美匹配。

那么合法当且仅当，对于每个第一象限内的左下角矩形 $(x,y)$，$(x,y)$ 内的先生的度数之和，都 $\ge$ 学生的个数。

好像很难做，但是我们的学生是有特殊性质的——只有左下角和右上角有点。

所以可以直接排成一排，从小到大地贪心匹配即可。

## 103. Flappy Bird

同。

直接做就行。

## 104. Judge Error

同。

众所周知带花树是 $O(nm^2)=O(n^5)$ 的，但是跑不满，所以有可能过！（不是

根据 [Kotzig's theorem on perfect matchings](https://arxiv.org/pdf/1402.0949)，一个点双连通图如果存在完美匹配，那么至少存在两个完美匹配。

考虑圆方树，或者其实没有必要。有一个很聪明的想法。

考虑一个生成树，如果子树内结点个数为奇数，且**没有**连出子树外的边，那么我们可以发现这个点与父亲的边是*必选的*。

然后就可以把这两个点删掉了，递归继续做。

由于上面的定理，我们必然可以找到这样的边。

怎么判断这个东西呢？有一个很巧妙的方法——异或哈希。

给每条边赋一个随机权值，每个点的权值是所有邻边的权值的异或值。

我们算出子树异或和，然后判断其是否等于父边即可。

## 105. Advanced Evolution Studies

考虑我们现在在根上面，则我们将要要求对于所有四元组 $(a,b,c,d)$，$a$ 和 $b$ 都一定要在同一个子树中。我们考虑用并查集维护这个东西，最终不在同一个集合的就分到不同子树中递归计算。

如果 $c$ 和 $d$ 也被分到一个集合而且跟 $a$ 和 $b$ 不在一个集合，那么我们还得把这两个集合合并。

如果一次无法进一步分裂了，即存在矛盾，输出 -1。

## 106. Joy of Sushi

记 $t=q(n+1)+r$，$s_i=\sum_{j=1}^{i}b_j$

则合法当且仅当 $\forall 1\le i\le n,a_i+q\cdot s_{n+1}+s_{i+r-1}-s_{i-1}\equiv 0\pmod k$，这里把 $b$ 复制了一份再做前缀和 $s$。

考虑枚举 $r$，显然 $q\cdot s_{n+1}\bmod k$ 是一定的，所以我们要求 $a_i+s_{i+r-1}-s_{i-1}$ 相同。

……等等怎么 $n$ 这么小，直接枚举就做完了。解这个 $q$ 用一个 exgcd 即可。

## 107. Kid's Game

超现实数……

我感觉直接贪心选即可。

## 108. Colorful Doors

首先如何构造「全部都要走」的情况？

注意到交叉的情况可以全部走完，所以可以构造：

```
1,2,1,2,3,4,3,4,5,6,5,6,...
```

当 $2\mid N$ 可以构造出来，对于 $2\nmid N$，可以证明不存在解。

对于不能走的位置，我们一定是直接跳过去，判断是否 $2\mid \sum (l_i-1)$，其中 $l_i$ 表示 0 段的长度即可。然后删掉之后就转化为上面的情况。

## 109. Construct Point

Pick's 定理基础练习题。

对于任意一个网格上的简单多边形，其面积 $A$，边界上的格点数 $B$ 和内部格点数 $I$ 满足

$$
A=I+B/2-1
$$

然后我们就能轻松判断无解的情况。

怎么构造解呢？考虑二分他的位置，如果范围足够小就可以靠取整得到一个答案。

## 110. Rectangles

有解当且仅当 $a|A\land b|B\land c|C$。

考虑二维的情况，不难发现要么 $x$ 轴错开要么 $y$ 轴错开，所以答案是 $ab(a+b)$。

那么三维是什么？其实也差不多。

但是要使用容斥。

// 没看懂

## 111. Simple APSP Problem

首先如果一个黑色格子都没有，则答案为

$$
\sum_{i=0}^{H-1}\sum_{j=0}^{W-1}(H-i)(W-j)(i+j)=\frac{1}{12} (H^3-H)(W^2-W)+\frac{1}{12}(W^3-W)(H^2-H)
$$

曼哈顿距离其实很难受到影响，可以发现受影响的点的个数不超过 $O(N^2)$ 个，所以直接处理即可。

## 112. Hamilton

不妨假设 $a<b$。

注意到 $\gcd(1,*)=1$，所以我们可以在任何时候访问或者离开 $1$。

但是 $n$ 不一定满足这个，而访问或者离开 $n$ 是必需的。

实际上我们只需要关注所有的关键点——$1,a-1,a+1,b-1,b+1,n$，讨论他们的互质情况，即可求出答案。可以发现答案 $\le 3$，否则无解。

## 113. I've Got Friends

考虑所有喜欢同一种食物的人，发现构成一个团。

考虑对于一个 $a$ 的所有邻居，可以发现一定至多可以划分成两个团。

只要满足这个条件就一定合法。

---

实际上这道题是要求你把[线图](https://en.wikipedia.org/wiki/Line_graph)恢复为原图。

## 114. Best Subsequence

考虑二分答案，变成要求选的子序列中相邻两项的和都 $\le mid$。

考虑所有 $\le mid/2$ 的元素形成的连续段，则相邻两个连续段中间的东西中最多选一个出来，显然就是选出来最小的元素，然后判断一下是否合法即可。

然后就做完了？

## 115. Cool pairs

构造题野蛮，数数题文明，，，

首先如果我们在 $p_1$ 放 $-n$，则可以给到恰好 $n-p_1$ 的贡献，假如我们决定不在 $b$ 放 $n$。

然后我们一直这么放，直到放不了。

则我们从 $q_n$ 开始填 $n-1$，直到减去剩下的元素恰好为 $0$，然后在 $p_i$ 填 $-n+1$，剩下的随便填 $0$ 即可。

## 116. Unfair Card Deck

感觉可以模拟退火啊🤓👆

## 117. Permutasino

感觉直接选择循环矩阵然后高斯消元即可。

## 118. Humongous String

恶心的推式子题。

---

1. **特殊情况 $k = 1$**

   显然，如果 $k = 1$，答案就是 $n$。

---

1. **基本概念**
   
   考虑无限字符串
   $$
   U = T_0 T_1 T_2 \cdots
   $$
   我们把每个 $T_i$ 称作一个 **块（block）**。如果块 $T_i$ 以字符 $s_t$ 结尾（即 $i \bmod k = t$），我们称其为 **$t$-块**。

* **大块（big block）**：若两个相邻块 $T_i T_{i+1}$ 中 $T_i$ 是 $(k-1)$-块（$T_{i+1}$ 是 $0$-块），则把它们的连接称为大块；否则，它们之间有一个 **边界（border）**，记作 `|`。
* **常规块（regular block）**：$1 ≤ t ≤ k-2$ 的 $t$-块。

**性质**：两个相邻字符 $s_i$ 和 $s_j$ 之间只有当 $j = (i+1) \bmod k$ 时，才没有边界分隔。

* 当 $k \ge 3$ 时，$U$ 结构如下：
  $$
  T_0 | \cdots | T_{k-2} | T_{k-1} T_k | T_{k+1} | \cdots
  $$
* 当 $k = 2$ 时，
  $$
  U = T_0 | T_1 T_2 | T_3 T_4 | T_5 T_6 | \cdots
  $$

**关键观察**：

* 如果有限子串包含至少两个边界，它在 $U$ 中最多出现一次，因为所有常规块和大块长度不同。
* 对每个块 $B$（大小 $> k+1$），其左侧最大块是该块的上一个大块。
* 连续 $a$-块长度差为 $k$（$1 ≤ a < k-1$），连续大块长度差为 $2k$。

---

1. **$old(B, i)$ 的定义**

设
$$
old(B, i)
$$
表示以块 $B$ 的第 $i$ 个字符结尾的子串，在该字符之前的前缀中已出现过的次数。

于是答案为：
$$
\frac{n(n+1)}{2} - \sum_{i=1}^{n} old(B,i)
$$

---

4. **$old(B, i)$ 的公式**

    设 $b$ 为块 $B$ 的第一子块长度。

    **当 $k \ge 3$ 时：**

    $$
    old(B,i)=
    \begin{cases}
    i, & b \le k, i < b \\
    0, & b \le k, i = b \\
    i, & b = k+1 \\
    i + b - k -1, & B \text{ 是大块}, 2b+1-i \ge 2k \\
    i - k, & B \text{ 是大块}, 2b+1-i < 2k \\
    i + 2b - 3 - 2k, & b \bmod k = 2, b-i \ge k \\
    i, & b \bmod k = 2, b-i < k \\
    i + b - k -1, & b \bmod k > 2, b-i \ge k \\
    i, & b \bmod k > 2, b-i < k
    \end{cases}
    $$

    **当 $k = 2$ 时：**

    $$
    old(B,i)=
    \begin{cases}
    i + 2b + 1 - 4k, & b \ge 4, 2b+1-i \ge 2k \\
    i - k, & b \ge 4, 2b+1-i < 2k \\
    |i-1|, & b=2 \\
    1, & b=1
    \end{cases}
    $$

---

5. **公式证明思路**

    设 $P_{Bi}$ 为以块 $B$ 的第 $i$ 个字符结尾的前缀。

    * 对 $k \ge 3$：

      1. 若 $B$ 是前 $k+1$ 个块之一，且 $i \ne b$ 或 $i=b=k+1$，则长度为 $i$ 的后缀至少在前一个块出现过，较长的后缀不会出现（含 $sb-2$ 第一次出现）。
      2. 若 $B$ 是前 $k$ 个块之一，且 $i=b$，则任何后缀都没有前次出现（含 $sb-1$ 第一次出现）。
      3. 否则，根据块类型（常规块或大块）及 $i$ 的值，后缀在前一个大块或前一个 $a$-块出现过，若后缀跨边界，则其出现位置受到限制。

    * 对 $k=2$：

        唯一不同是没有常规块，公式稍作修改即可。

---

6. **求和方法**

   * 将每个块最多拆成两部分，使得每部分的 $old(B,i)$ 对 $i$ 是线性函数，可表示为
     $$
     AL^2 + BL + C
     $$
     其中 $L$ 为该部分长度。可用整数幂求和公式计算。
   * 每个 $a$-块（$1<a<k-1$）、$1$-块或大块的 $old(B,i)$ 求和分别为多项式 $P(b)$、$Q(b)$、$R(b)$，次数 $≤ 2$。
   * 对完整块及部分块分别求和即可得到前 $n$ 个字符的总和。
   * 对某些特殊 $i$（如 $k+1, 2k+1, …$），通过重写 $R(x)=P(x)+P(x+1)+S(x)$、$Q(x)=P(x)+T(x)$ 可修正。
   * 最终所有求和可在 $O(1)$ 时间内计算。

---

**结论**

通过上述方法，可以在 **$O(1)$ 时间** 内计算出前 $n$ 个字符中不同非空子串的数量。

## 119. K-Triangles

分讨所有的形态和相对位置关系，然后可以变成二维偏序。