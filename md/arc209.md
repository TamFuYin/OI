unrated

## A

注意太郎君的局面一定是合法的；次郎君的局面一定是不合法的。

因此操作过程完全由太郎君决定，我们考虑嵌套的 `()` 个数即可。

## B

注意到偶回文串必然存在两个相邻字符相同。

如果 $s$ 不存在绝对众数，那么答案就是 $0$。

否则一定是尽量均匀地安排绝对众数的段最优。

## C

如果没有区间查询，我们可以这样做

```c++
for(int i=1;i<=n;i++) ans+=p[i];
for(int i=n-1;i>=1;i--){
    if(p[i+1]==1) l=(s[i+1]+r-1)/r,r=x;
    else r=std::min((s[i+1]+l-1)/l-1,x),l=1;
    if(l>r) --ans,l=1,r=x;
}
```

注意到每个时刻要么 $l=1$ 要么 $r=x$

所以可以数论分块预处理每个位置值是什么的时候，什么时候到达 $l>r$。

然后就是一个类似倍增的东西。

对于剩下的一段，我们可以离线用并查集处理。

## D

这题放 A 才差不多……

对于一个 $A_i=-1$，如果存在 $j<i$，使 $A_j=i$，那么让 $A_i=1$ 是最优的。

否则，我们需要让 $A_i$ 指向一个 $A_j=1$。

如果我们做完了上面的操作，依然未出现 $A_i=1$ 的位置，那么我们找到最后面的 $-1$ 的位置填上 $1$，然后前面指向他即可。

特别的，如果只有一个位置未确定，那么我们让他指向 $A_i$ 的最小值。

## E

抽象。

注意到题目约束 $N-K\le 100$

考虑令 $K\gets N-K$，然后问题变为「最少删掉 $K$ 个字符使其不包含 `ABC` 子序列」。

考虑子序列自动机，不过我们只保留 `A` 到 `B` 和 `B` 到 `C` 的边，然后你发现这个东西形如求一个最小割。

根据 MCMF 定理，最小割等于最大流，你发现就是取出不重复的 `ABC` 子序列的最大数目。

直接对这个子序列自动机的状态做 DP 复杂度是 $O(NK^3)$。

考虑容斥，变为能够取出至少 $K$ 个 `ABC` 子序列的个数。

考虑我们已经拿出来 $K$ 个 `ABC` 了，然后令 $N\gets N-3K$。