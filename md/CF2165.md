# Codeforces Round 1064 (Div. 1)

## A. Cyclic Merging

如果是序列上的，则显然按照大根笛卡尔树的顺序自底向上合并最优，所以答案就是 $\sum a_i\times ([a_{i-1}<a_i]+[a_{i+1}\le a_i])$，其中我们认为 $a_0=a_{n+1}=+\infin$。

然后断环为链，可以快速判断。

## B. Marble Council

考虑我们拿到一个 $s$，怎样放最有可能成立？

显然对于 $s$ 中的相同元素，我们只拿出一个集合把剩余的这个元素全部放进去，然后可以把其他元素尽量塞进去。

因此合法当且仅当 $\sum_{c\in s}(|a|_c-|s|_c+1)\ge \max_{c\notin s}|a|_c$

考虑枚举右边那个取什么，然后就是一个组合数

## C. Binary Wine

这种结构貌似见过很多次了

考虑找到 $c$ 的最高位，不妨记为 $j$。

- 如果存在 $a_i\ge 2^{j+1}$，合法。
- 否则，如果存在至少两个 $a_i\ge 2^j$，合法。
- 否则，如果不存在 $a_i\ge 2^j$，不合法
- 否则，对于唯一的一个 $2^j\le a_i<2^{j+1}$，令 $a_i\gets a_i-2^j,c\gets c-2^j$，然后 $j\gets j-1$

考虑这个过程，显然我们只需要在不合法的时候，找到最大的 $a_i$，让它加上 $2^j-a_i$。

直接模拟就做完了

## D. Path Split

~~考虑每个点 $i$ 连向下一个满足 $a_j-a_i=1$ 的 $j$ 和 $a_j-a_i=-1$ 的 $j$，有结论我们一定只会使用这些边。~~

~~然后就是一个 DAG 最少链剖分的问题，网络流即可~~

这个结论好象是错的。

然而，我们仍然可以把每个 $i$ 连向所有满足 $|a_i-a_j|=1$ 的 $j>i$。

等等我好想在哪里见过这个 trick……而且我甚至当时做出来了。

注意到 $a_i=1$ 会比 $a_i=3$ 更严格，考虑从小到大迭代 $v$，然后贪心地匹配右侧第一个 $v+1$，然后这样就是对的。

## E. Rainbow Branch

注意到每种颜色一定是选一个连通分量最优，这样每种颜色就可以缩成一个圆方树状物，然后答案就是直径。

考虑增量法，每次在一个连通块内选择一个度数最大的点，然后就可以把它分裂成若干个点，且答案最多增加 $1$。

~~具体的，维护树的直径，对于未达到直径的点可以直接延展直到到达。~~

~~然后也是贪心选取，感觉一定是最优的。~~

实际上答案有一定的结构，可以直接求出来。

由于是最小化一个直径状物，所以肯定是缩掉树的中点附近的东西最优。

对于 $k$ 为奇数，我们直接删掉外面一圈叶子。

否则，我们允许一个分支高度多一点，

## F. Arctic Acquisition

考虑所有的极小锯齿区间，设 $f_l$ 表示最小的 $r$ 满足 $[l,r]$ 合法，我们的任务就是求出这个。

由于是极小，所以我们的 $l$ 已经是 $i_1$ 了，我们往后找到第一个 $i_2$ 满足 $a_{i_2}<a_{i_1}$（可以与处理出），然后询问 $(i_2,n]$ 中是否存在 $i_3,i_4,i_5$ 满足 $a_{i_4}>a_l$。

我们考虑从大到小加入 $a$，则当加入 $a_l$ 时，只需判断 $(i_2,n]$ 是否存在一个:heavy_check_mark:结构即可。

我们可以维护包含这个结构的最短后缀。每次加入一个元素时，找到右边的最大元素，然后找到左边小于这个元素的最大出现位置，然后就可以更新答案了。不难使用主席树维护。