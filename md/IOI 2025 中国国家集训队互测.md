# 2024-2025 集训队互测

## Round 1

### 基础 ABC 练习题

神秘定理：记 $s_{o,i}$ 表示前 $i$ 个数中 $o$ 字符的出现次数，记

$$
A=\max_{1\le i\le 3n} s_{a,i}-s_{c,i}\\
B=\max_{1\le i\le 3n} s_{b,i}-s_{a,i}\\
C=\max_{1\le i\le 3n} s_{c,i}-s_{b,i}
$$

则序列合法充要于 $A+B+C\le n$。

必要性：可以发现 $A\le$ `ABC` 的出现次数，$B,C$ 同理，由于 `ABC`、`BCA`、`CAB` 的出现次数总和为 $n$，所以 $A+B+C\le n$。

充分性：考虑第 $i$ 个 `A`，第 $i+B$ 个 `B`，第 $i+B+C$ 个 `C`（模意义下）组合在一起。

到这里就能做出来 [agc055_d](https://atcoder.jp/contests/agc055/tasks/agc055_d) 了。

考虑拓展一下，可以发现对于所有 $x\ge A,y\ge B,z\ge C,x+y+z=n$ 的三元组 $(x,y,z)$ 都存在一种方式使其恰好划分为 $x$ 个 `ABC`，$y$ 个 `BCA`，$z$ 个 `CAB`。

可以归纳证明。

然后就能 DP 了，记一下当前填的 `A`,`B`,`C` 的个数，以及 $A,B,C$ 的值即可。

注意到我们只需要知道 $A,B,C$ 是否达到上界，简单反演一下即可。

### 基础 01? 练习题

第一次见到 TM 串的地方。

直接枚举 TM 拆分的位置，做一个容斥即可。

### 基础 01 练习题

考虑矩阵转二分图，连 $i\to j$ 如果 $A_{i,j}=1$，否则连 $i\leftarrow j$。

怎么把 $B$ 放上去？考虑把 $B_{i,j}$ 作为 $i\sim j$ 的边权，把 $B_{j,i}$ 作为 $j\sim i$ 的边权。

然后你发现条件为：对于任意一条（有向）路径，权值非严格递增。

考虑对 $A$ 强连缩点，则对于每个 SCC 内部权值都相同。

考虑如果两个点，如果其连边情况完全相同，则我们称这两个点等价，可以合并掉。

我们可以证明合并完之后图的拓扑序唯一，也就是说强连缩点之后形成一条链。

因为如果存在两个入度为零的点，如果在同一侧，那么是等价的；否则，由于不可能出现 $i\to j$ 又 $i\leftarrow j$ 的情况，所以矛盾。

这条链其实是可以预先求出来的，按出度大小排序即可。

接下来我们考虑通过度数序列刻画可达性。

对于度数相同的点，他们之间可能是之前去重时删掉的点，此时他们必然互相不可达，也有可能是部分留在了原图中，这样度数相同的点必然在同一个 SCC 中，互相可达。

对于度数不同的点，度数大的点必然能到达度数小的点。



## Round 2

### 生命的循环

强连缩点之后，就不会做了

数论困难

### 树上简单求和

考虑树剖套树分块，可以证明时间复杂度可以做到根号，比一般的树分块好用（其实差不多）

两边的操作都可以差分，所以我们只需要思考 DFS 序上的前缀与前缀之间的贡献。

整-整和整-散贡献可以预处理，散-散直接暴力，然后就做完了。

### 路径计数

困难？

## Round 3

### 环上排序信息最优分割

环上邮局

### 研心

考虑

- 左侧最长回文
- 右侧最长回文
- 中心在左侧的最长回文
- 中心在右侧的最长回文

四种贡献对答案矩阵 ckmax。

考虑枚举左侧的一个合法的回文中心，则相当于匹配右侧的 LCP。

考虑对右侧建 Trie，把一个东西挂到上面，则相当于对一个祖链做一个类似 ckmax 的东西。

有点复杂，但是是可做的。

### 无限地狱

困难题

## Round 4

### Désive

考虑 Trie 上每个叶子的贡献。

我们枚举它最多到了哪步之前保持兄弟子树满员，可以得到 $O(2^nn)$ 个矩阵 ckmax 信息。

对于 $o=1$，就是单点求值。

对于 $o=2$，就是区间历史和。

### 分道扬镳

按照性价比 $w/v$ 排序，按照贪心选的方案再在根号范围内微调 DP 即可。

为了避免被卡，还可以随机打乱。方法是如果这个元素在贪心方案中被选，那么加入它的相反数。

### 观虫我

经典算法是 $O(2^{n/2}q)$。

后面太神秘了

## Round 5

### 长野原龙势流星群

玩原玩的。

好眼熟，果然正睿的题都是抄的吧（

发现形如对子节点的答案做 max-plus 卷积，树上启发式合并维护 slope trick 即可，可以二分找切线。

### Classical Counting Problem

标题缩写很危险呐

考虑建出大根树上笛卡尔树 $T_{\max}$ 和小根树上笛卡尔树 $T_{\min}$。

从小到大（从大到小）加入节点，然后用并查集维护即可。

那么一个最小值为 $l$，最大值为 $r$ 的连通块可以看作 $T_{\min}$ 上 $l$ 的子树和 $T_{\max}$ 上 $r$ 的子树的交集。

考虑每个节点的贡献，形如若干个 $\min\times \max$ 之和。

直接统计在两棵重构树上的祖先链上的 min 和 max 之和再乘起来感觉就是对的？

### [运筹帷幄 / 《十字神名的预言者》理解（色彩）](https://www.luogu.com.cn/problem/P11690)

显然我们每次把一个最深的棋子提到能放的最上面是最优的。

用线段树合并维护可以做到单次 $O(n\log n)$，下标为深度，值为棋子个数。

如果用长剖可以做到单次 $O(n)$。

记 $f_{u,i}$ 表示 $u$ 子树内操作完后到 $u$ 距离 $\ge i$ 的棋子数量。

记 $g_{u,i}$ 表示 $u$ 子树内操作完后到 $u$ 距离 $\ge i$ 的棋子的距离和。

转移不难。

不妨记 $\mathrm{hs}_u$ 表示 $u$ 的长儿子。

我们每次

1. $f_u\gets f_{\mathrm{hs}_u},g_u\gets g_{\mathrm{hs}_u}$
2. $\forall v\ne \mathrm{hs}_u,f_u\gets f_u+f_v,g_u\gets g_u+g_v$
3. 在 $f$ 上二分找到前 $a_u-b_u$ 大的元素将其删除，并更新答案。

现在考虑换根 DP。

考虑用<ruby>重链剖分<rt>DSU on tree</rt></ruby>维护，不妨记 $u$ 的重儿子为 $\mathrm{ws}_u$。

通过长链剖分，我们可以知道每个点子树内信息，但是我们还想知道子树外的信息。

考虑把它分成三部分：

- 祖先链，这个最简单
- 树链剖分的余链，即 $u$ 到根的路径上经过的轻结点的的父亲的重儿子子树
- 其他，即 $u$ 到根的路径上经过的重结点的的父亲的轻儿子子树

对于第二条，由于只有 $O(\log n)$ 棵子树，我们用一个集合 $S$ 存储这些信息的根节点。

对于第三条，记 $F_{u,i}$ 表示到 $u$ 距离 $\ge i$ 的棋子数量，$G_{u,i}$ 类似。

然而实际上我们维护的信息不是这些，往下看。

当前在结点 $u$，我们每次：

1. 二分删除距离前 $a_x-b_x$ 大的元素。注意到我们的 $S$ 是有序的，所以可以按顺序枚举一遍看看能否删空，这样最多只需要二分一次。由于第 5 条操作，我们保证 $S$ 中维护的信息一定比 $F$ 和 $f$ 中维护的信息要远，所以在全部删空 $S$ 之后再在 $F$ 和 $f$ 同时做一次二分即可。
2. 根据 $f_u,g_u$ 回退到 $f_{\mathrm{hs}_u},g_{\mathrm{hs}_u}$，此时我们知道 $u$ 的所有儿子的子树贡献数组。
3. 把所有的轻儿子的贡献加入 $F$，由于数组长度不超过 height 同时也不超过 size，所以这一步是均摊 $O(\log n)$ 的。
4. 进入重儿子 $\mathrm{ws}_u$
5. 进入轻儿子 $v$，我们将 $v$ 在 $F$ 内的贡献删除，然后截取重儿子距离 $\le \mathrm{siz}_v$ 的部分放到 $F_v$，剩余部分放在 $F_{\mathrm{ws}_u}$，对于重儿子 $f_{\mathrm{ws}_u}$ 中 $>\mathrm{siz}_v$ 的部分，我们将重儿子的结点编号 $\mathrm{ws}_u$ 加入 $S$ 内并记录 $\mathrm{siz}_v$。这个操作保证了 $S$ 维护的信息一定要比 $F$ 和 $f$ 远，且空间复杂度为线性。
6. 将 $f_{\mathrm{hs}_u},g_{\mathrm{hs}_u}$ 还原成 $f_u,g_u$。

观止矣！若有他法，吾不敢请已。

## Round 6

### 树数叔术

好困难

### 欧伊昔

subtask1 是 $\rm DFT_3$。

可以发现运算表是一个三阶张量，然而三阶张量的 CP 分解是 NP-hard。

然后<ruby>挑战 NPC <rt>乱搞</rt></ruby>即可。

### 人间应又雪

注意到最优情况下必然存在一个 $p$ 使得所有向左的操作都 $\ge p$，向右的操作都 $\le p$。

我们考虑枚举这个 $p$，再枚举向左的操作和向右的操作的总数，判断是否可行。

考虑 DP。不妨只考虑左边的操作（向右）。

设 $f_i$ 表示现在 DP 到 $i$，前 $1\sim i$ 的都是合法的，其中最少需要多少次操作。

转移不难。

然后就能做到 $O(nm^2)$。

如果二分答案 $t$，每次枚举向右操作的次数，即可做到 $O(nm\log m)$。

实际上我们不需要枚举这个分界点。

我们记 $pl_j$ 表示允许有 $t-j$ 个向左的操作，用 $j$ 个向右操作能清空的最长的前缀，且此时还剩下 $cl_j$ 个向右操作。

然后可以用类似 CF1876G 的技巧维护。

## Round 7

