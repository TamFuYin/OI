中国語版本。

不妨假设 $n,m,V$ 同阶。

首先大概可以用带修莫队之类的高级技巧做到 $O(n^{\frac 53}\log n)$，但是没什么前途。

先考虑不带修改怎么做。

考虑求 mex 的[经典做法](https://www.luogu.com.cn/problem/P4137)：从左到右扫一遍，维护每个颜色上一次出现的时间。然后在 $r$ 时第一个 $<l$ 的值即为 mex。对于 $k$-th mex，就是找到第 $k$ 个 $<l$ 的值。

一般的做法是用持久化线段树维护，但是这里肯定是做不了的。

这种信息貌似只能通过值域分块来维护，每块维护一个平衡树，时间复杂度是 $O(\frac nB\log n+B)$，可以平衡复杂度做到 $O(\sqrt{n\log n})$

现在考虑怎么做修改操作，你发现这个东西也是困难的，因为一次修改就把后面维护的信息全部动完了。

注意到我们的信息少量拓展是容易的，但是极其难以合并。

考虑对序列分块，我们只在每一块的右端点记录信息，则每次修改只会更改 $O(\sqrt n)$ 个信息。

具体而言，对于一次修改操作 $(l,r,x,y)$。我们找到 $<l$ 的最近的信息，不妨记为 $L$。我们只要关心 $L$ 的整块信息和区间 $(L,l)$ 的散块信息中 $x$ 和 $y$ 的上一次出现位置，即能更新 $\ge l$ 的 $x$ 和 $y$ 的信息，扫一遍做即可，这样每次修改的时间复杂度是 $O(B+\frac nB\log n)$，平衡复杂度 $O(n\sqrt {n\log n})$。

这样我们总共分出来 $O(B^2)=O(n\log n)$ 块

查询的时候，不难花 $O(B)$ 的代价把剩余部分补齐。

实现的时候，可以对每块信息都开一个动态开点权值树状数组，应该比 splay/treap 之流或者权值线段树快。