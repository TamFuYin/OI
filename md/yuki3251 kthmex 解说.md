中国語版本。

首先不难用莫队或者根号重构做到 $O(n\sqrt n\log n)$，但是没什么前途。

回顾一下求 mex 的[经典做法](https://www.luogu.com.cn/problem/P4137)：从左到右扫一遍，维护每个颜色上一次出现的时间。然后在 $r$ 时第一个 $<l$ 的值即为 mex。对于 $k$-th mex，就是找到第 $k$ 个 $<l$ 的值。

一般的做法是用持久化线段树维护，但是这里肯定是做不了的。

考虑对序列分块，我们只在每一块的右端点记录信息，则每次修改只会更改 $O(\sqrt n)$ 个信息。

具体而言，对于一次修改操作 $(l,r,x,y)$。我们找到 $<l$ 的最近的信息，不妨记为 $L$。我们只要关心 $L$ 的整块信息和区间 $(L,l)$ 的散块信息中 $x$ 和 $y$ 的上一次出现位置，即能更新 $\ge l$ 的 $x$ 和 $y$ 的信息，扫一遍做即可，时间复杂度是 $O(\sqrt n)$ 的。

然而，为了查询，我们还想知道前缀 min 信息。