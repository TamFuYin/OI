看完只有一个想法：

# 信息学不存在了

果然每次 UOI 都能惊艳到我。

[maspy](https://atcoder.jp/users/maspy) 到底是那个星球来的神仙啊……

## 储存处无

原地求逆排列。

## Again Counting Stars

注意到对于每个形如 $s\to t\to s$ 的路径，我们会让 $\min(s,t)$ 减一，让 $\max(s,t)$ 加一。

## Ad-hoc Master II

## 我的 XOR 卷积人生

## 成王败寇

## 程序校验 II

lxl 又发力了

#### Subtask 1

暴力模拟

#### Subtask 2，3

同[「清华集训 2014」玄学](https://www.luogu.com.cn/problem/P11721)。

考虑用线段树整理所有操作，维护处理完区间内所有操作之后的数组形态（这里的数组 $f_i$ 表示「如果 $X$ 一开始为 $i$ 最终变成什么」），不难发现只有 $O(操作次数)$ 段不同的，所以预处理阶段的复杂度是 $O(\log n)$ 的（归并排序）。

然后对于一段区间的 $l,r$，我们可以把它拆成 $O(\log n)$ 段区间。每次用 $X$ 遍历一遍可以做到 $O(q\log^2 n)$，因为还要二分一次找到位置。

实际上上面的想法可以用线段树分散层叠算法优化到一个 $\log$，但是我不会。

#### Subtask 4

这道题比「清华集训 2014」玄学好的地方就是没有动态增广这种恶心的操作。

所以考虑用一些神秘持久化数据结构维护这个东西，然后就能变成离线。

如果所有 $r=n$，则可以倒着扫描线，然后用持久化平衡树维护当前的 $f_i$。

然而这里是区间操作的，可以参考[UOJ Σ* Round #1 题解>程序校验>算法 6](https://liu-cheng-ao.blog.uoj.ac/blog/9507)。

大体思想是：可持久化数据结构形如一个深度为 $O(\log)$ 的 DAG，其中每个入度为 $0$ 的点对应一个历史版本的入口。

咕咕

#### Subtask 5

咕咕

