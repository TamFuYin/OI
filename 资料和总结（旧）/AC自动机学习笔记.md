# AC自动机学习笔记

[自动 AC 机](https://www.luogu.com.cn/problem/T205934)（滑稽

AC 自动机其实就是在 Trie 上跑 KMP。

## 失败指针

在自动机中，我们从初始结点出发，不断接受字符串的信号（相应的边权）而达到状态（结点）。(我用 $\text{next}_c[u]$ 表示从 $u$ 走 $c$ 边转移到的结点)

Trie 就是一个典型的自动机，容易发现 Trie 上的每一个状态都对应一个模式串的一个前缀。而 AC 自动机正是 Trie 的 Pro Max 版，新添匹配功能。

具体来说，AC 自动机有 fail 指针，u 的 fail 指针指向 u 的真后缀中最长且在 Trie 中的那个在 Trie 中对应的状态。如果 Trie 只有一条单链，那么这个退化为 KMP 中的最长 border。特殊的，起始结点的 fail 指向自己。

fail 指针的构造也可以类比 KMP，令 $s=t+c$，其中 $t$ 是 $s$ 的最长真前缀（前驱），$c$ 是一个字符，要想找到 $s$ 的最长真后缀，可以先看看 $\text {fail}[t]$ 是否有 $c$ 这条出边，如果有的话，$\text {fail}[t]+c$ 就是 $s$ 的一个真后缀，而且不难证明它是最长的，否则可以跳至后缀的后缀，如果在初始结点处失败了，说明 $c$ 不在字典树里，我们直接让它的 fail 指针指向初始结点即可，因为空串一定是它的后缀。

## 真正的 AC 自动机

我们发现上述构造方案需要跳很多次 fail。事实上，AC 自动机的功能要求它尽量跳 next 在后尾增加，跳不到就跳 fail 在前面减少直到可以跳，这样，AC 自动机接受串 S 后得到的状态一定是 S 的最长后缀，我们只保证这个性质就可以了，因此不必严格的使用 Trie。

因此我们修改定义，令 $\text{next}_c[s]$ 表示 $s+c$ 在字典树中最长的后缀。

如是我们就可以这样构造：

- 如果 Trie 中有 $\text{next}_c[s]$，那么 $\text{fail}[\text{next}_c[s]]=\text{next}_c[\text{fail}[s]]$。

- 否则，$\text{next}_c[s]=\text{next}_c[\text{fail}[s]]$。

再次提醒：$\text{next}_c[\text{fail}[s]]$ 表示的是 $\text{fail}[s]+c$ 在字典树中最长的后缀。

##  多串匹配

现在匹配就变得非常简单了，不断跳 next 就可以了，但是这样会漏掉一些状态，因此需要在每个状态跳一下 fail。

但是每次跳 fail 也是极慢的，因此我们可以使用树上差分+拓扑排序来优化。

具体而言，fail 指向更短的串，且最终指向空串（初始结点），因而 fail 指针构成一棵根向树（忽略根的自指）。

## DP

AC 自动机的 DP 题大部分都很板。

大部分都是给出一堆模式串，然后统计/最优化某个不包含这些串的文本串（有时要容斥）。

然后设`f[i][j]`为文本串第`i`个位置走到 AC 自动机的结点`j`时的答案。

DP 的时候注意不要转移到模式串就可以了。

即，在插入的时候在模式串结尾的地方打标记，由于 fail 树中它的子结点都包含它，因而它的子结点都统统不能要。

最后在最后一个位置的所有结点的答案累计起来就可以了。

怎么样，是不是相当简单呢！