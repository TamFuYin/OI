$$

$$

$$
f_i=\sum_{1\le j\le i,j} f_j
$$

一个单调，一个不单调。

s~i~-s~j-1~>=X

s~j-1~<=s~i~-X

算出对每个r~i~最小的l~i~，使l~i~ ~ r~i~的种类<=m

按s~r~排序

按s~i-1~排序，依次在位置i加入1

在加入和结束前，如果s~i-1~>s[r~top~]-X，ans+=sum(l~top~,r~top~).



求满足两个性质——l~r的总数<=M且和>=X——的区间的数目

要用线段树

本来想到了一个完美的O(NlogN)的平衡树做法

但毕竟难打

于是使劲想

这时我想到了整体二分！

是的，一个相似的求小于某个数且位置在某范围内的数的数量问题！

而且线段树和树状数组在功能上不能说是完全一样只能说是一模一样！~~不是一个意思么~~

于是就有了上面的思路。这实在是对“时间”这一概念的巧妙应用！

重点在于变形s~l-1~<=s~r~-X上

我们把两边都进行排序

然后强行是其与时间搭上关系：我们找到对于每个r使不等式成立的最大的s~l-1~，因为我们是按s~i-1~加入的，所以，前面放进了线段树的l都是可以的。

代码

```c++
#include<cstdio>
#define ll long long
const ll N=1e5+10,E4=1e4;
struct QuJian
{
	ll l,r,sr;
}qj[N];
struct SortPut
{
	ll v,i;
}sp[N];
ll a[N],s[N],ap[N];
#include<algorithm>
using std::sort;
bool comp_qj(QuJian a,QuJian b)
{
	return a.sr<b.sr;
}
bool comp_sp(SortPut a,SortPut b)
{
	return a.v<b.v;
}
ll t[N*4],n;
ll sum(ll ql,ll qr,ll l=1,ll r=n,ll o=1)
{
//	if(ql<=l&&r<=qr) printf("%lld~%lld+",l,r);
	if(ql<=l&&r<=qr) return t[o];
	ll mid=l+r>>1,ret=0;
	if(ql<=mid) ret+=sum(ql,qr,l,mid,o<<1);
	if(mid<qr) ret+=sum(ql,qr,mid+1,r,o<<1|1);
	return ret;
}
void plus(ll i,ll v,ll l=1,ll r=n,ll o=1)
{
	t[o]+=v;
	if(l==r) return;
	ll mid=l+r>>1;
	if(i<=mid) plus(i,v,l,mid,o<<1);
	if(mid<i) plus(i,v,mid+1,r,o<<1|1);
}
int main()
{
	freopen("lantern.in","r",stdin);
	freopen("lantern.out","w",stdout);
	ll m,x,l=1,apsum=0,ans=0;
	scanf("%lld%lld%lld",&n,&m,&x);
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		if(!ap[a[i]+E4]) apsum++;
		ap[a[i]+E4]++;
		while(apsum>m)
		{
			ap[a[l]+E4]--;
			if(!ap[a[l]+E4]) apsum--;
			l++;
		}
		s[i]=s[i-1]+a[i];
		qj[i]=(QuJian){l,i,s[i]};
		sp[i]=(SortPut){s[i-1],i};
	}
	sort(qj+1,qj+n+1,comp_qj);
	sort(sp+1,sp+n+1,comp_sp);
	ll top=1;
	for(ll i=1;i<=n;i++)
	{
		while(sp[i].v>s[qj[top].r]-x&&top<=n)
		{
//			printf("%lld~%lld=",qj[top].l,qj[top].r);
			ans+=sum(qj[top].l,qj[top].r)*2-sum(qj[top].r,qj[top].r);
//			printf("\n");
			++top;
		}
//		printf("%lld\n",sp[i].i);
		plus(sp[i].i,1);
	}
	while(top<=n)
	{
		ans+=sum(qj[top].l,qj[top].r)*2-sum(qj[top].r,qj[top].r);
		++top;
	}
	printf("%lld",ans);
}
```

结构体爱好者狂喜。sort爱好者狂喜。

一千五byte左右的代码量，只能说是一般般。但如果我像以前一样乖乖的打了两个sort，恐怕会更多。

但是如果用平衡树的话~~也许~~肯定代码量会更大

~~虽然用普通的BST也可能可以骗得过去但毕竟是假的时间复杂度呢~~

总的来说，是一道中档题，很适合我的难度呢！ 