## 整体二分

### 前言

那是一个悲惨的回忆。

那是 **2022-08-11**的晚上。夏日炎炎。

我打算攻克JZOJ2908. 【集训队互测 2012】矩阵乘法(mat) 。

我翻看了各种题解、资料和某wiki。~~然而完全没看懂~~

于是我去问讲题人麦奆。

* 麦奆，此题怎么解？

* 如此……这般…………（讲了一堆我会的）。然后使用整体二分优化……
* 等等，整体二分怎么打？
* ……你去看一下[OI Wiki](https://oi-wiki.org/misc/parallel-binsearch/)，他讲的很好的，实在不会的话可以看着他的代码学，我也是这么学会的……

我就这样被一个XXS鄙夷了。~~虽然是一个完全比不上的大奆~~

于是我只好一个字符一个字符的看代码学习

### 整体二分



#### 例题

##### [JZOJ矩阵乘法](https://gmoj.net/senior/#main/show/2908)

> 有一个N*N的矩阵和Q次询问，每次给出一个子矩阵，求其中的第k小的元素。

hash，把二分范围缩小到1~ N*N。同时因为相等的元素不好处理，把它弄成一个1~N *N的排列。

我们假设mid是所有询问的答案。

我们同时把大矩阵内小于等于mid的元素标记起来（其实就是往二维树状数组里的这个位置加上一）。

对于每一个询问，我们算出（当然是用树状数组的求和功能啦）子矩阵内被标记元素的个数。

我们知道所谓“某元素在子矩阵中排名第k”，事实上就是“子矩阵中有k个数小于等于它”的意思。

也就是说，如果mid真的是当前询问的答案，那么我们算出来的被标记元素的个数就等于k。

如果比k小，那就说明mid小了，反之则mid大了。

我们把所有的询问分成两类，一类是答案比mid小的，另一类是答案比mid大的。

然后愉快地递归。

然而大犇曰：

> 复杂度不允许与矩阵大小线性相关，只能与被标记元素个数相关。
>
> ​																									——许昊然《浅谈数据结构题几个非经典解法》

就是说，我们清空树状数组准备进入下一层时，**不能用memset，不能用memset，不能用memset**。因为memset的时间和矩阵大小相关，哪怕它能一次刷一个字节而且速度超级快，它也是O(N*N)的。所以虽然看起来快，但是冗余操作比你看起来的多得多，遇到大数据就Go Die了。

呜呼，古今死于memset者多少耶？！

但是不用memset用什么呢？
没错！就是你想的那个，直接用最暴力的方法，用加-1的方法复原！

```cpp
#include<cstdio>
#define N 510
#define Q 60010
#define INF 0x7ffffff
#define lowbit(x) ((x)&(-(x)))
#define ll long long
ll n,m;
ll ans[Q];
ll t[N][N];
ll a[N][N];
ll sum_y(ll t[],ll p)
{
	if(p<0) return 0;
	ll ret=0;
	while(p>0)
	{
//		printf("%lld\n",p);
		ret+=t[p];
		p-=lowbit(p);
	}
	return ret;
}
ll sum(ll p,ll y1,ll y2)
{
	ll ret=0;
	while(p>0)
	{
//		printf(":%lld %lld %lld\n",p,y1,y2);
		ret+=sum_y(t[p],y2)-sum_y(t[p],y1-1);
		p-=lowbit(p);
	}
	return ret;
}
void add_y(ll t[],ll p,ll x)
{
	while(p<=n)
	{
		t[p]+=x;
		p+=lowbit(p);
	}
}
void add(ll p,ll x)
{
	ll y=(p-1)%n+1;
	p=(p+n-1)/n;
	while(p<=n)
	{
		add_y(t[p],y,x);
		p+=lowbit(p);
	}
}
ll tot=0;
struct query
{
	ll x1,y1,x2,y2,k,id,type;
}q[N*N+Q],q1[N*N+Q],q2[N*N+Q];
void solve(ll l,ll r,ll ql,ll qr)
{
	if(ql>qr) return;
	if(l==r)
	{
		for(ll i=ql;i<=qr;i++)
		if(q[i].type==2) ans[q[i].id]=l;
		return;
	}
	ll mid=l+r>>1,cnt1=0,cnt2=0;
	for(ll i=ql;i<=qr;i++)
	{
		if(q[i].type==1)
		{
			if(q[i].x1<=mid)
			{
				add(q[i].id,1);
				q1[++cnt1]=q[i];
			}
			else
			{
				q2[++cnt2]=q[i];
			}
		}
		else
		{
			ll x=sum(q[i].x2,q[i].y1,q[i].y2)-sum(q[i].x1-1,q[i].y1,q[i].y2);
			if(q[i].k<=x)
			{
				q1[++cnt1]=q[i];
			}
			else
			{
				q[i].k-=x;
				q2[++cnt2]=q[i];
			}
		}
	}
	for(ll i=1;i<=cnt1;i++)
	if(q1[i].type==1) add(q1[i].id,-1);
	for(ll i=1;i<=cnt1;i++) q[i+ql-1]=q1[i];
	for(ll i=1;i<=cnt2;i++) q[i+cnt1+ql-1]=q2[i];
	solve(l,mid,ql,cnt1+ql-1);
	solve(mid+1,r,cnt1+ql,qr);
}
struct hash_int
{
	ll data,x,y;
}hs[N*N];
ll b[N];
void sort_hs(ll l,ll r)
{
	ll i=l,j=r,mid=hs[l+r>>1].data;
	while(i<=j)
	{
		while(hs[i].data<mid) ++i;
		while(mid<hs[j].data) --j;
		if(i<=j)
		{
			hash_int p=hs[i];hs[i]=hs[j];hs[j]=p;
			++i,--j;
		}
	}
	if(i<r) sort_hs(i,r);
	if(l<j) sort_hs(l,j);
}
ll raw[N*N];
int main()
{
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=n;j++)
		{
			scanf("%lld",&hs[(i-1)*n+j].data);
			hs[(i-1)*n+j].x=i;
			hs[(i-1)*n+j].y=j;
		}
	}
	sort_hs(1,n*n);
	for(ll i=1;i<=n*n;i++)
	{
		a[hs[i].x][hs[i].y]=i;
		raw[i]=hs[i].data;
	}
	for(ll i=1;i<=n;i++) for(ll j=1;j<=n;j++)
	q[++tot]=(query){a[i][j],-1,-1,-1,-1,(i-1)*n+j,1};
	for(ll i=1,x1,y1,x2,y2,k;i<=m;i++)
	{
		scanf("%lld%lld%lld%lld%lld",&x1,&y1,&x2,&y2,&k);
		q[++tot]=(query){x1,y1,x2,y2,k,i,2};
	}
	solve(0,a[hs[n*n].x][hs[n*n].y]+1,1,tot);
	for(ll i=1;i<=m;i++)
	printf("%lld\n",raw[ans[i]]);
}
```

