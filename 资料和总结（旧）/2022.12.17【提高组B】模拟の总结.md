# 2022.12.17【提高组B】模拟の总结



## T0 活动

这是一道简单的DP题。设f~i,j~为**有i个物品，**
$$
f_{i,j}=\sum_{\frac{j}{2}\leq k\leq min(n,j),k\neq y}f_{i-1,j-k}=s_{j-\frac{j}{2}}-s_{j-min(n,j)-1}-f_{i-1,j-y}
$$
注意最多能放lg(n)+2件物品，永远不要吝啬你的循环

## T1 差分

> 来到集上，见某人正在一个OJ门口站着，散着头发，满脸污泥，鞋都跑掉了一只，兀自拍着掌，口里叫道：“中了！中了！”

我™终于A了！

此题细节繁多，BUG迭出，防不胜防，甚费脑干，而题解、讲题甚简，谬误极多，不知所云。然而我耗尽网课的时间摸鱼，终于A了这道题！！！

所以，~~啊哈哈哈，题解来喽！~~在此我献上我的题解。:bow:

一如题解所说咱可以分x>0,x=0,x<0三种情况讨论。

若x>0。我们就可以想办法令所有的$a_i-a_{i-1}\leq0$，即排成一个递减序列。但是还有一个特殊情况，即d~0~=a~0~，意思是说，排头的那一个不能是x。对此，我们可以在递减序列里找到一个非0非x的数并与a~0~交换。容易证明这样做可以保证改动过的那几个位置上（的差分数组）都不会有x。

若x<0。同x>0，甚至更简单。因为题目保证a数组都是非负整数，故此时a~0~绝不会等于x。

若x=0。来了来了。题解云：“但是实际构造的过程中可以借助一个优先队列，每次都出队当前次数最多的数字即可。”*事实上这里的说法有误，应该是每次出队当前次数最多的数字（刚出过队的除外），为此我们可以把已经输出的数的次数弄成零然后再找到它的继承人后在弄回来*。 实现上，我们都知道priority_queue。但是尊敬的熊老师不允许我们在训练的时候用STL，所以只好用堆（当然是大根堆啦）来自己实现。~~其实线段树也可以。~~大体流程如下：
  ```
  临时=当前输出的数的次数-1
  输出(当前输出的数)
  当前输出的数的次数=0
  向下调整(当前输出的数)
  下一个要输出的数=堆顶
  当前输出的数=临时
  向上调整(当前输出的数)
  ```
注意这里有两个坑：

1. 在向上调整的过程中，“下一个要输出的数”的位置要跟着他的交换而改变，~~除非你用指针~~；
2. 一个首尾都是0 的构造是不合格的。首先我们想到第一位是0的情况也许是难以避免的，于是我们就想办法使最后一位尽量不是0。这等价于让0的出现提前，于是我们可以在调整的过程中进行一系列特判，让0尽量往上走。

时间复杂度：O(TNlogN)=O(TN)=O(ΣN)=2×10^6^，可行

## T2 

## T3

约定：0左脚，1右脚。则有
$$
f_{u,0}=\max(f_{nex_u,1},0)+v_u\\
f_{u,1}=\max(f_{nex_u,0},0)-v_u
$$
tempfultion
