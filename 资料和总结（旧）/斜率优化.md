# 斜率优化

一种DP优化，可以用来加速这样的DP式子：（其中的x~j~ 单调递增)
$$
b_{i}=\min_{j<i}(y_{j}-k_{i} \times x_{j})
$$
考虑几何意义。

观察到我们的式子实际上等价于**有一个点集和一个斜率，找到一个点使得过该点的直线的截距最小**。

![从某维基盗来的图](https://oi-wiki.org//dp/images/optimization.svg)

一个一个地尝试显然是冗余的。我们发现这样的点显然在点集的下凸包上。换句话说，我们只要维护好下凸包就好了。

因为x~j~是递增的，所以我们可以用单调栈维护。即保持过当前点与上个点的直线的斜率的递增。

- [ ] 如果k~i~也是递增的，那么我们可以把它改成单调队列，然后均摊O(1)得到b~i~。

> ##### 为何是单调队列？如何维护单调队列？
>
> 如果凸包上没有一条边的斜率与k~i~相等，那么k~i~大于作为答案的那一个点往下往左的那一条边的斜率而小于往上往右的那一条边的斜率。否则与k~i~相等的斜率的那条边的两个端点都是答案。如果k~i~是递增的话，这个作为答案的点就一定会往上往右移动，因此我们可以断定，*斜率小于等于k~i~的边一定用不着*，于是可以把这样的边的左（下）端点出队。队首即为所求。入队的话，不就是求凸包嘛:smile:

- [ ] 否则的话，可以在凸包上二分斜率。

如果k~i~是递减的，那也简单，就是把下凸包换成上凸包。

求出b~i~后以此算出x~i~和y~i~然后入队。

例题：[JZOJ玩具装箱](https://gmoj.net/senior/#main/show/1116)

```cpp
#include<cstdio>
#include<cmath>
#define ll long long
#define ld long double//注意斜率的精度问题
const ll N=50010;
ll s[N],f[N],q[N];
ld getk(ll p1,ll p2)
{
	ld x1=s[p1],x2=s[p2],y1=f[p1]+s[p1]*s[p1],y2=f[p2]+s[p2]*s[p2];
	return (y1-y2)/(x1-x2);
}
int main()
{
	ll n,l;
	scanf("%lld%lld",&n,&l);l++;
	for(ll i=1;i<=n;i++)
	{
		ll temp;
		scanf("%lld",&temp);
		s[i]=s[i-1]+temp+1;
	}
	ll head=1,tail=1;
	for(ll i=1;i<=n;i++)
	{
		ld ki=-2*(l-s[i]);
		while(head<tail&&getk(q[head],q[head+1])<=ki)
		head++;
		ll j=q[head];
		f[i]=f[j]+pow(s[i]-s[j]-l,2);
		while(head<tail&&getk(q[tail-1],q[tail])>=getk(q[tail],i)) tail--;
		q[++tail]=i;
	}
	printf("%lld",f[n]);
}
```

例题：[JZOJ T2](https://gmoj.net/senior/#main/show/7600)（这是k~i~递减的情况）

```cpp
#include<cstdio>
#include<cmath>
#define ll long long
#define ld long double
const ll N=1000010;
ll n,a,b,c;
ll s[N],f[N],q[N];
ld getk(ll p1,ll p2)
{
	ld x1=s[p1],x2=s[p2],y1=f[p1]+a*s[p1]*s[p1]-b*s[p1],y2=f[p2]+a*s[p2]*s[p2]-b*s[p2];
	return (y1-y2)/(x1-x2);
}
int main()
{
	scanf("%lld%lld%lld%lld",&n,&a,&b,&c);
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&s[i]);
		s[i]+=s[i-1];
	}
	ll head=1,tail=1;
	for(ll i=1;i<=n;i++)
	{
		ld ki=2*a*s[i];
		while(head<tail&&getk(q[head],q[head+1])>=ki) head++;
		ll j=q[head];
		f[i]=f[j]+a*pow(s[i]-s[j],2)+b*(s[i]-s[j])+c;
		while(head<tail&&getk(q[tail-1],q[tail])<=getk(q[tail],i)) tail--;
		q[++tail]=i;
	}
	printf("%lld",f[n]);
}
```

等等，万一x~j~不是单调的呢。

例题：[JZOJ 城市交通](https://gmoj.net/senior/#main/show/1749)

如果设f~i~为1号节点到i的距离，则有
$$
\ \begin{eqnarray}\label{eq}
f_i&=&\min(f_j+(i-j)\cdot A_j+B_i)\nonumber\\
f_i&=&\min(f_j+i\cdot A_j-j\cdot A_j+B_i)\nonumber\\
f_i&=&\min(f_j-j\cdot A_j+i\cdot A_j)+B_i\\
f_i-B_i&=&\min(f_j-j\cdot A_j+i\cdot A_j)
\end{eqnarray}
$$

根据b=y-kx,有:

$$
\ \begin{eqnarray}
b&=&f_i-B_i\nonumber\\
k&=&i\nonumber\\
x&=&-A_j\nonumber\\
y&=&f_j-j\cdot A_j
\end{eqnarray}
$$

可以看出k递增。唯一的麻烦是x没有单调性。

怎么办呢？我们有一个办法，就是从后往前推！

更改DP的状态定义：设f~i~为i到n号节点的距离。则有：

$$
\ \begin{eqnarray}
f_i&=&\min(f_j+(j-i)\cdot A_i+B_j)\nonumber\\
f_i&=&\min(f_j+j\cdot A_i-i\cdot A_i+B_j)\nonumber\\
f_i&=&\min(f_j+j\cdot A_i+B_j)-i\cdot A_i\\
f_i+i\cdot A_i&=&\min(f_j+B_j+j\cdot A_i)
\end{eqnarray}
$$

根据b=y-kx,有:

$$
\ \begin{eqnarray}
b&=&f_i+i\cdot A_i\nonumber\\
k&=&A_i\nonumber\\
x&=&-j\nonumber\\
y&=&f_j+B_j
\end{eqnarray}
$$

然后我们的x就递增了（因为我们是从后往前推的）。但是k没有单调性，我们可以在凸包（用单调栈维护）上二分找出答案。

上面的例题实际上使用了**更改状态设计**的优化

## 结合线段树分治

### [SDOI2014]向量集

##### 题目描述

维护一个向量集合，在线支持以下操作：

- `A x y`（$|x|,|y| \le 10^8$）：加入向量 $(x,y)$；
- `Q x y l r`（$|x|,|y| \le 10^8$，$1 \le l \le r \le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。

集合初始时为空。

##### 解法

设若答案为ans，询问为x~0~,y~0~则

$ans=\max\{x_0x+y_0y\}$

进而$\frac{ans}{y_0}=\max\{\frac{x_0}{y_0}x+y\}$

这道题求得是max，故维护上凸包。

然后线段树分治一下