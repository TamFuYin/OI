# 最大流和增广路算法

## Dinic算法

所谓Dinic算法大致分两个步骤。

一是用BFS对当前的残量网络分层。

每个点的层数就是它距源点的最近距离（边数）。

> ##### 那为什么要分层呢？
>
> 有两个好处：
>
> 1. 如果没有增广路了，那么汇点的层数就也不会存在，然后就可以直接 Over 了。
> 2. 如果我们只找比当前点的层数多一的点进行增广，那么增广路的长度就是汇点的层数，而汇点的层数是它距源点的最近距离，这样我们可以确保我们找到的增广路最短。

二是用DFS找增广路。我们只找比当前点的层数多一的点进行增广。找完后回溯的时候就可以完成增广操作。

Dinic有2个优化：

1. **多路增广**：我们找到一条增广路的时候，有时还会有剩余的流量没有用完，此时又要重新再跑一遍，很浪费时间。其实我们可以利用剩余的流量在一次DFS中找出多条增广路，提高效率。

2. **当前弧优化**：如果一条边已经被增广过了，就不能再增广了。

最坏时间复杂度是$O(n^2m)$

在二分图中时间复杂度是$O(m\sqrt n)$

# 最小割

## 割

对于一个网络 $G$，我们定义*割* 是 $V$ 的一种划分方式。

即把 $V$ 划分为 $S+T=V$。其中 $s∈S,t∈T$。

也就是把选中一些边把它割掉，然后使 $s$ 不能到达 $t$。

割的容量记作 $c(S,T)$ 或 $c(s,t)$。

即选中的边的容量之和。

我们定义 $f(A,B)$ 为两个点集A到B的流函数。

即 $f(A,B)=\sum_{u\in A,v\in B,(u,v)\in E}f(u,v)$

也就是两个点集间相连的边的流量之和。

由流量守恒定律，$f(s,t)=f(S,T)$。

而当 $f(S,T)$ 最大时，$f(S,T)$=S出边的总流量-S入边的总流量=S出边的总流量=$\min c(s,t)$

所以$\max f(s,t)=\min c(s,t)$

感性理解：割是流的限制，所以最大流=最小割。

# 费用流

就是每条边上除了容量限制，还有费用。费用实际上是每单位''水''流过需要的费用，即流量为 $f(u,v)$ 的边费用为 $f(u,v)\times w(u,v)$

求源点到汇点的所有最大流中费用最小的最大流。称为最小费用最大流。

## SSP算法

只需将EK算法或Dinic算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。

显然反向边的费用等于原边的费用的相反数。因此图上会存在费用为负的边，所以不能用Dijkstra，被迫使用SPFA。

# 经典模型

## 二分图最大匹配

二分图最大匹配既可以用匈牙利算法，也可以用网络流。

s连向A中的每个点，A、B中的边改为有向边，B中的每个点连向t。然后跑最大流就可以了。

二分图最小点覆盖=二分图最大匹配=点数-二分图最大独立集。

### ![img](https://s2.ax1x.com/2019/07/30/eJF1Bj.png)

### DAG 最小路径覆盖

考虑每个点 $u$ 拆成一个出点 $u$ 和入点 $u'$，对于原 DAG 中的一条边 $(u,v)$，连接 $u$ 和 $v'$。然后跑二分图最大匹配。每一次“匹配”相当于一次路径的合并，因此最小路径覆盖 $=|V|-$ 最大匹配。同样也可以发现等价于最小点覆盖。

### DAG 最长反链

DAG 最长反链=最小可重叠路径覆盖=传递闭包的最小路径覆盖。



## 二分图最大点权匹配

源点向二分图左部连边权为其点权的边，二分图右部连边权为其点权的边向汇点，中间把原图的边改为有向边，容量为+inf。然后跑最大流。此时

在二分图中，二分图最大(点权)匹配=二分图最小点覆盖=|V|-二分图最大独立集=最大流。

## 最大权闭合子图

闭合子图就是在一个有向图中，子图中的每一个节点的出边连向的点依然在子图内。

最大权闭合子图就是使点权的和最大的闭合子图。

很多题目都可以转化为最大权闭合子图模型求解。

## 最大权闭合子图与最小割

建图，原图中的边的容量为正无穷（以便其不会被割）。s连向点权为正数的点，容量为点权；点权为负数的点连向t，容量为点权的相反数。

结论：

1. 最小割所产生的两个集合中的S（除去s），是最大权闭合图
2. 最大权闭合子图权值 = 所有权值为正的权值之和 - 最大流

# 最小费用循环流

> ## [Question](https://www.luogu.com.cn/problem/UVA1659)
>
> Laura Luo刚刚发明了一个游戏。给定一个有n个点的美丽铅笔草图，你需要使用水笔上色，通过绘制电路。每次绘制新的电路时，从一个点开始，沿着一些线段行进并返回起点。每个点可以被多次到达，但每个线段最多只能被绘制一次。为了使图片看起来有趣，不同的线段必须用不同的颜色绘制。对于每个线段，Laura已经决定了绘制的方向。下面的图片说明了绘制图片的一个可能方式（虚线表示未绘制的线段）。绘制完毕后，您的得分计算如下：对于每个绘制的单位长度，您获得x个分数；对于每个使用的颜色，您失去y个分数（Laura已经准备了足够数量的不同颜色的水笔）。编写一个程序来找出您可以获得的最大分数。输入 输入包含几个测试用例。每个测试用例的第一行包含三个正整数n、x、y（1 ≤ n ≤ 100，1 ≤ x，y ≤ 1000）。接下来的n行描述了一个点（点按出现在输入中的顺序从1到n进行编号）。前两个整数（x，y）指定其坐标（0 ≤ x，y ≤ 1000）。其余的整数是它连接到的点，以0结尾。如果点v出现在点u的列表中，则u和v之间有一个线段连接（然后在反向方向上将没有连接u和v的线段）。此外，Laura将从u绘制到v。列表中不会有重复的点，且线段数不会超过500。最后一个测试用例后面跟着一个0，不应进行处理。输出 对于每个测试用例，打印案例编号和您可以获得的最大分数，精确到小数点后两位。
>
> ~~ChatGPT 翻译的~~
>
> 发现每条边的「分数」是 $dx-y$，其中 $d$ 是两个点的欧几里得距离。
>
> 试找出一些没有边相交的圈，使得分数最大。

现在没有源点和汇点了，我们的目标是在残量网络上找出一些负圈进行增广（因为正圈还不如不走），求出最小的费用（注意，我们允许残量网络存在有向环，即我们的目标不是“最大流”下的最小费用流）。

方法是强行使负权边**满流**。

问题来了，我们哪来的那么多流？凭空使其满流会使得它不合法。为此，我们给它造个源、汇点。容易发现，如果有一条源点→某个点→汇点的路径，两条边容量相等，费用为零，那么对答案没有影响。

因此对每一条负权边，给起点连一条从源点来的边，给汇点连一条到汇点去的边，容量都是该负权边的容量，然后直接流。这当然会对答案产生影响，但是可以根据上文的方法“补全”两个点。

即
$$
s\xrightarrow[c]{0} u\xrightarrow[c]{-w} v\xrightarrow[c]{0} t
$$

直接给它流一个流量为 $c$ 的流。流完之后就变成了

$$
s\xrightarrow[c]{0} v\xrightarrow[c]{w} u\xrightarrow[c]{0} t
$$

建一个新图。原来的正权边不变。建源、汇点。对于每条负权边 $u\to v$，在新图中建 $v\to u$，费用为原来的相反数，再建 $s\to v,u\to t$，费用为 $0$，上述容量均为该负权边的容量。

这样建边的弊端之一是边数太多了，对于每个点 $u$，如果所有的 $s\to u$ 的容量之和为 $\sigma_s$；所有的 $u\to t$ 的容量之和为 $\sigma_t$，那么可以合并为一条容量为 $|\sigma_s-\sigma_t|$ 边，方向自己想。这是因为所有的这些边的费用都是 $0$。

然后跑最小费用流，如果所有的与源、汇相连的边都跑满了，说明得到了一个可行流，而且费用是最小的（证明略~~其实是不会~~）

然后用最小费用流给出的结果加上事先给负权边流的部分就得到最后的答案了。

# 上下界最大流

朴素的想法：给每条边流一个它的下界，这样它的残量网络就是一个正常的网络流了，每条边的残余容量就是上界减去下界。可是有一个致命的问题：网络流要求“流量平衡”，即每个点的入流等于出流。

和上文的方法一样：如果有一条源点→某个点→汇点的路径，两条边容量相等，那么对答案的贡献仅为该流量。

因此多出来的流我们假想它流到了汇点，同理可以让源点来承担流量赤字，最后用这个方法补全。最后用答案减去这个过程中产生的虚流量即可。

[板子](https://www.luogu.com.cn/problem/P5192)：

```c++
#include<bits/stdc++.h>
namespace net{
    const int INF=1e9,N=1e7,M=1e7;
    int nx[M],ca[M],ls[N],to[M],tot=1;
    void addedge(int u,int v,int cap){
        nx[++tot]=ls[u];
        to[ls[u]=tot]=v;
        ca[tot]=cap;
    }
    void add(int u,int v,int cap){
        addedge(u,v,cap);
        addedge(v,u,0);
    }
    int S,T;
    int flow[N];//净入流量
    void add(int u,int v,int low,int up){
        flow[u]-=low;
        flow[v]+=low;
        if(up-low>0) add(u,v,up-low);
    }
    int deledge(int u,int v){
        for(int i=ls[u],last=0;i;last=i,i=nx[i]){
            if(to[i]==v){
                if(!last) ls[u]=nx[i];
                else nx[last]=nx[i];
                return ca[i];
            }
        }
        return 114514;
    }
    int q[N],dep[N],cur[N];
    int SIZE;bool vis[N];
    bool bfs(){
        memcpy(cur+1,ls+1,sizeof(int)*SIZE);
        std::fill(dep+1,dep+SIZE+1,INF);
        int head=0,tail=1;
        dep[q[1]=S]=0;
        while(head<tail){
            int u=q[++head];vis[u]=0;
            for(int i=ls[u];i;i=nx[i]){
                if(ca[i]&&dep[to[i]]>dep[u]+1){
                    dep[to[i]]=dep[u]+1;
                    if(!vis[to[i]]) vis[q[++tail]=to[i]]=1;
                }
            }
        }
        return dep[T]<INF;
    }
    int dfs(int u,int flow=INF){
        if(u==T) return flow;
        int ret=0;
        for(int &i=cur[u];i&&flow;i=nx[i])
        if(ca[i]&&dep[to[i]]==dep[u]+1){
            int f=dfs(to[i],std::min(flow,ca[i]));
            if(f) ca[i]-=f,ca[i^1]+=f,flow-=f,ret+=f;
            else dep[to[i]]=0;
        }
        return ret;
    }
    int dinic(){
        int ret=0,tmp;
        while(bfs()) while(tmp=dfs(S)) ret+=tmp;
        return ret;
    }
    int maxflow(int n,int s,int t){//let 's flow !!!
        add(t,s,0,INF);
        int ext=0;S=n+1,T=n+2;SIZE=n+2;
        for(int i=1;i<=n;i++){
            if(flow[i]<0) add(i,T,-flow[i]);
            if(flow[i]>0) add(S,i,flow[i]),ext+=flow[i];
        }
        int f=dinic();
        if(f<ext) return -1;
        int prerun=deledge(s,t);deledge(t,s);
        S=s;T=t;SIZE=n;
        return dinic()+prerun;
    }
    void clear(){
        memset(ls+1,0,sizeof(int)*(SIZE+2));tot=1;
        memset(flow+1,0,sizeof(int)*SIZE);
    }
}
namespace IO{
    int read(){
        char c=getchar();int ret=0;
        while(c<'0'||c>'9') c=getchar();
        while(c>='0'&&c<='9') ret=ret*10+c-'0',c=getchar();
        return ret;
    }
}
int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        net::clear();
        int s=n+m+1,t=s+1;
        for(int i=1;i<=m;i++) net::add(n+i,t,IO::read(),net::INF);
        for(int i=1;i<=n;i++){
            int c=IO::read();
            net::add(s,i,0,IO::read());
            while(c--){
                int tt=IO::read(),l=IO::read(),r=IO::read();
                net::add(i,n+tt+1,l,r);
            }
        }
        printf("%d\n\n",net::maxflow(n+m+2,s,t));
    }
}
```



# 有负圈的费用流

强制使负边满流。

[板子](https://www.luogu.com.cn/problem/P7173)：
```c++
#include<bits/stdc++.h>
const int N=1e5,M=1e6;
int ls[N],nx[M],ca[M],va[M],to[M],tot=1;
int addedge(int u,int v,int c,int p){
    nx[++tot]=ls[u];
    to[ls[u]=tot]=v;
    ca[tot]=c;
    va[tot]=p;
    return tot;
}
int _add(int u,int v,int c,int f){
    int ret=addedge(u,v,c,f);
    addedge(v,u,0,-f);
    return ret;
}
int ans;
int in_flow[N];//净入流量
int add(int u,int v,int c,int f){
    if(f>=0) return _add(u,v,c,f);
    in_flow[v]+=c;
    in_flow[u]-=c;
    ans+=c*f;
    return _add(v,u,c,-f);
}
const int INF=1e9;
int q[N],dis[N],cur[N];
bool vis[N];
bool bfs(int s,int t){
    memset(dis,0x3f,sizeof dis);
    memcpy(cur,ls,sizeof ls);
    dis[q[1]=s]=0;
    int head=0,tail=1;
    while(head<tail){
        int u=q[++head];vis[u]=0;
        for(int i=ls[u];i;i=nx[i]){
            if(ca[i]&&dis[to[i]]>dis[u]+va[i]){
                dis[to[i]]=dis[u]+va[i];
                if(!vis[to[i]]) vis[q[++tail]=to[i]]=1;
            }
        }
    }
    return dis[t]<INF;
}
int dfs(int u,int t,int flow=INF){
    if(u==t) return flow;
    vis[u]=1;
    int ret=0;
    for(int& i=cur[u];i&&flow;i=nx[i]){
        if(!vis[to[i]]&&ca[i]&&dis[to[i]]==dis[u]+va[i]){
            int f=dfs(to[i],t,std::min(ca[i],flow));
            if(f) ca[i]-=f,ca[i^1]+=f,ret+=f,flow-=f,ans+=f*va[i];
        }
    }
    vis[u]=0;
    return ret;
}
int dinic(int s,int t){
    int ret=0;
    while(bfs(s,t)) ret+=dfs(s,t);
    return ret;
}
int size;
int maxflow(int s,int t){
    int ts=_add(t,s,INF,0),S=size+1,T=size+2,sum=0;
    for(int i=1;i<=size;i++){
        if(in_flow[i]>0) _add(S,i,in_flow[i],0),sum+=in_flow[i];
        if(in_flow[i]<0) _add(i,T,-in_flow[i],0);
    }
    if(dinic(S,T)<sum) return -1;
    // printf("%d %d\n",ca[ts],ca[ts^1]);
    int pre=ca[ts^1];ca[ts]=ca[ts^1]=0;
    return dinic(s,t)+pre;
}
int main(){
    int n,m,s,t;scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1,x,y,f,v;i<=m;i++) scanf("%d%d%d%d",&x,&y,&f,&v),add(x,y,f,v);
    size=n;int mf=maxflow(s,t);
    printf("%d %d",mf,ans);
}
```